{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/codes/RayTracing.glsl","path":"codes/RayTracing.glsl","modified":1,"renderable":0},{"_id":"source/images/Directx11_01_04.png","path":"images/Directx11_01_04.png","modified":1,"renderable":0},{"_id":"source/images/Directx11_01_05.png","path":"images/Directx11_01_05.png","modified":1,"renderable":0},{"_id":"source/images/Directx11_01_10.png","path":"images/Directx11_01_10.png","modified":1,"renderable":0},{"_id":"source/images/Directx11_02_01.png","path":"images/Directx11_02_01.png","modified":1,"renderable":0},{"_id":"source/images/Directx11_02_03.png","path":"images/Directx11_02_03.png","modified":1,"renderable":0},{"_id":"source/images/RTR4.02.02.png","path":"images/RTR4.02.02.png","modified":1,"renderable":0},{"_id":"source/images/RTR4.02.03.png","path":"images/RTR4.02.03.png","modified":1,"renderable":0},{"_id":"source/images/RTR4.02.08.png","path":"images/RTR4.02.08.png","modified":1,"renderable":0},{"_id":"source/images/RTR4.03.02.png","path":"images/RTR4.03.02.png","modified":1,"renderable":0},{"_id":"source/images/RTR4.03.03.png","path":"images/RTR4.03.03.png","modified":1,"renderable":0},{"_id":"source/images/RTR4_02_01.png","path":"images/RTR4_02_01.png","modified":1,"renderable":0},{"_id":"source/images/RTR4_04_01.png","path":"images/RTR4_04_01.png","modified":1,"renderable":0},{"_id":"source/images/Shadertoy_01_03.png","path":"images/Shadertoy_01_03.png","modified":1,"renderable":0},{"_id":"source/images/Shadertoy_01_04.png","path":"images/Shadertoy_01_04.png","modified":1,"renderable":0},{"_id":"source/images/Shadertoy_01_01.png","path":"images/Shadertoy_01_01.png","modified":1,"renderable":0},{"_id":"source/images/Shadertoy_01_05.png","path":"images/Shadertoy_01_05.png","modified":1,"renderable":0},{"_id":"source/images/Shadertoy_02_02.png","path":"images/Shadertoy_02_02.png","modified":1,"renderable":0},{"_id":"source/images/Shadertoy_02_03.png","path":"images/Shadertoy_02_03.png","modified":1,"renderable":0},{"_id":"source/images/Shadertoy_03_01.png","path":"images/Shadertoy_03_01.png","modified":1,"renderable":0},{"_id":"source/images/Shadertoy_04_02.png","path":"images/Shadertoy_04_02.png","modified":1,"renderable":0},{"_id":"source/images/Shadertoy_04_09.png","path":"images/Shadertoy_04_09.png","modified":1,"renderable":0},{"_id":"source/images/Directx11_01_01.png","path":"images/Directx11_01_01.png","modified":1,"renderable":0},{"_id":"source/images/Directx11_02_02.png","path":"images/Directx11_02_02.png","modified":1,"renderable":0},{"_id":"source/images/Shadertoy_04_06.png","path":"images/Shadertoy_04_06.png","modified":1,"renderable":0},{"_id":"source/images/Shadertoy_04_08.png","path":"images/Shadertoy_04_08.png","modified":1,"renderable":0},{"_id":"source/images/DirectX11.png","path":"images/DirectX11.png","modified":1,"renderable":0},{"_id":"source/images/Shadertoy_04_04.png","path":"images/Shadertoy_04_04.png","modified":1,"renderable":0},{"_id":"themes/hueman/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/hueman/source/js/insight.js","path":"js/insight.js","modified":1,"renderable":1},{"_id":"themes/hueman/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"source/images/Directx11_01_03.png","path":"images/Directx11_01_03.png","modified":1,"renderable":0},{"_id":"source/images/Directx11_01_08.png","path":"images/Directx11_01_08.png","modified":1,"renderable":0},{"_id":"source/images/Shadertoy_01_02.gif","path":"images/Shadertoy_01_02.gif","modified":1,"renderable":0},{"_id":"source/images/Shadertoy_04_03.png","path":"images/Shadertoy_04_03.png","modified":1,"renderable":0},{"_id":"source/images/Directx11_01_07.png","path":"images/Directx11_01_07.png","modified":1,"renderable":0},{"_id":"source/images/Directx11_02_04.png","path":"images/Directx11_02_04.png","modified":1,"renderable":0},{"_id":"themes/hueman/source/css/images/logo-header.png","path":"css/images/logo-header.png","modified":1,"renderable":1},{"_id":"themes/hueman/source/css/images/opacity-10.png","path":"css/images/opacity-10.png","modified":1,"renderable":1},{"_id":"themes/hueman/source/css/images/s-left.png","path":"css/images/s-left.png","modified":1,"renderable":1},{"_id":"themes/hueman/source/css/images/thumb-default-small.png","path":"css/images/thumb-default-small.png","modified":1,"renderable":1},{"_id":"themes/hueman/source/css/images/thumb-default.png","path":"css/images/thumb-default.png","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/justified-gallery/jquery.justifiedGallery.min.js","path":"libs/justified-gallery/jquery.justifiedGallery.min.js","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/justified-gallery/justifiedGallery.min.css","path":"libs/justified-gallery/justifiedGallery.min.css","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/source-code-pro/styles.css","path":"libs/source-code-pro/styles.css","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/titillium-web/styles.css","path":"libs/titillium-web/styles.css","modified":1,"renderable":1},{"_id":"source/images/Shadertoy_04_01.png","path":"images/Shadertoy_04_01.png","modified":1,"renderable":0},{"_id":"source/images/Shadertoy_04_07.png","path":"images/Shadertoy_04_07.png","modified":1,"renderable":0},{"_id":"source/images/Directx11_01_06.png","path":"images/Directx11_01_06.png","modified":1,"renderable":0},{"_id":"source/images/Shadertoy_04_05.png","path":"images/Shadertoy_04_05.png","modified":1,"renderable":0},{"_id":"themes/hueman/source/libs/font-awesome/css/font-awesome.css","path":"libs/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/font-awesome/css/font-awesome.min.css","path":"libs/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/css/lg-fb-comment-box.css","path":"libs/lightgallery/css/lg-fb-comment-box.css","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/css/lg-fb-comment-box.css.map","path":"libs/lightgallery/css/lg-fb-comment-box.css.map","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/css/lg-fb-comment-box.min.css","path":"libs/lightgallery/css/lg-fb-comment-box.min.css","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/css/lg-transitions.css","path":"libs/lightgallery/css/lg-transitions.css","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/css/lg-transitions.css.map","path":"libs/lightgallery/css/lg-transitions.css.map","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/css/lg-transitions.min.css","path":"libs/lightgallery/css/lg-transitions.min.css","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/css/lightgallery.css","path":"libs/lightgallery/css/lightgallery.css","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/css/lightgallery.css.map","path":"libs/lightgallery/css/lightgallery.css.map","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/css/lightgallery.min.css","path":"libs/lightgallery/css/lightgallery.min.css","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/fonts/lg.eot","path":"libs/lightgallery/fonts/lg.eot","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/fonts/lg.svg","path":"libs/lightgallery/fonts/lg.svg","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/fonts/lg.ttf","path":"libs/lightgallery/fonts/lg.ttf","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/fonts/lg.woff","path":"libs/lightgallery/fonts/lg.woff","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/img/loading.gif","path":"libs/lightgallery/img/loading.gif","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/img/video-play.png","path":"libs/lightgallery/img/video-play.png","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/img/vimeo-play.png","path":"libs/lightgallery/img/vimeo-play.png","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/img/youtube-play.png","path":"libs/lightgallery/img/youtube-play.png","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-autoplay.js","path":"libs/lightgallery/js/lg-autoplay.js","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-autoplay.min.js","path":"libs/lightgallery/js/lg-autoplay.min.js","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-fullscreen.js","path":"libs/lightgallery/js/lg-fullscreen.js","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-fullscreen.min.js","path":"libs/lightgallery/js/lg-fullscreen.min.js","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-hash.js","path":"libs/lightgallery/js/lg-hash.js","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-hash.min.js","path":"libs/lightgallery/js/lg-hash.min.js","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-pager.js","path":"libs/lightgallery/js/lg-pager.js","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-pager.min.js","path":"libs/lightgallery/js/lg-pager.min.js","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-share.js","path":"libs/lightgallery/js/lg-share.js","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-share.min.js","path":"libs/lightgallery/js/lg-share.min.js","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-thumbnail.js","path":"libs/lightgallery/js/lg-thumbnail.js","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-thumbnail.min.js","path":"libs/lightgallery/js/lg-thumbnail.min.js","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-video.js","path":"libs/lightgallery/js/lg-video.js","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-video.min.js","path":"libs/lightgallery/js/lg-video.min.js","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-zoom.js","path":"libs/lightgallery/js/lg-zoom.js","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-zoom.min.js","path":"libs/lightgallery/js/lg-zoom.min.js","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/js/lightgallery.js","path":"libs/lightgallery/js/lightgallery.js","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/js/lightgallery.min.js","path":"libs/lightgallery/js/lightgallery.min.js","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","path":"libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","path":"libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/titillium-web/fonts/7XUFZ5tgS-tD6QamInJTcSo_WB_cotcEMUw1LsIE8mM.woff2","path":"libs/titillium-web/fonts/7XUFZ5tgS-tD6QamInJTcSo_WB_cotcEMUw1LsIE8mM.woff2","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/titillium-web/fonts/7XUFZ5tgS-tD6QamInJTcZSnX671uNZIV63UdXh3Mg0.woff2","path":"libs/titillium-web/fonts/7XUFZ5tgS-tD6QamInJTcZSnX671uNZIV63UdXh3Mg0.woff2","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/titillium-web/fonts/anMUvcNT0H1YN4FII8wpr4-67659ICLY8bMrYhtePPA.woff2","path":"libs/titillium-web/fonts/anMUvcNT0H1YN4FII8wpr4-67659ICLY8bMrYhtePPA.woff2","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/titillium-web/fonts/anMUvcNT0H1YN4FII8wpr46gJz9aNFrmnwBdd69aqzY.woff2","path":"libs/titillium-web/fonts/anMUvcNT0H1YN4FII8wpr46gJz9aNFrmnwBdd69aqzY.woff2","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/titillium-web/fonts/anMUvcNT0H1YN4FII8wpr9INifKjd1RJ3NxxEi9Cy2w.woff2","path":"libs/titillium-web/fonts/anMUvcNT0H1YN4FII8wpr9INifKjd1RJ3NxxEi9Cy2w.woff2","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/titillium-web/fonts/anMUvcNT0H1YN4FII8wpr_SNRT0fZ5CX-AqRkMYgJJo.woff2","path":"libs/titillium-web/fonts/anMUvcNT0H1YN4FII8wpr_SNRT0fZ5CX-AqRkMYgJJo.woff2","modified":1,"renderable":1},{"_id":"source/images/Directx11_01_09.png","path":"images/Directx11_01_09.png","modified":1,"renderable":0},{"_id":"source/images/Shadertoy_02_01.png","path":"images/Shadertoy_02_01.png","modified":1,"renderable":0},{"_id":"themes/hueman/source/libs/font-awesome/fonts/fontawesome-webfont.woff","path":"libs/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/font-awesome/fonts/fontawesome-webfont.woff2","path":"libs/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/jquery/3.3.1/jquery.min.js","path":"libs/jquery/3.3.1/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/font-awesome/fonts/FontAwesome.otf","path":"libs/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/font-awesome/fonts/fontawesome-webfont.eot","path":"libs/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/hueman/source/libs/font-awesome/fonts/fontawesome-webfont.ttf","path":"libs/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"source/images/Directx11_01_02.png","path":"images/Directx11_01_02.png","modified":1,"renderable":0},{"_id":"themes/hueman/source/libs/font-awesome/fonts/fontawesome-webfont.svg","path":"libs/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/hueman/.gitignore","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1589342681738},{"_id":"themes/hueman/LICENSE","hash":"f0c7cd0dcb6f00b98393878068ff3e6bf5f321f1","modified":1589342681738},{"_id":"themes/hueman/README.md","hash":"e40d2179c43b418e7763306e1fee45062fac0c57","modified":1589342681739},{"_id":"themes/hueman/_config.yml","hash":"31e8a16c0d4e6aab866a1c607d893da4d2ae7942","modified":1589342681740},{"_id":"themes/hueman/package.json","hash":"32b072ae0ab43c297e57dfd66bc8e4e6a589c329","modified":1589342681783},{"_id":"source/_posts/Directx11-01.md","hash":"e42b2d0f7bf9c0c4dbc835508f2b653d4005ff53","modified":1589342681661},{"_id":"source/_posts/Directx11-02.md","hash":"83bcd31a01e217392b01c62507728acbd86734d9","modified":1589342681661},{"_id":"source/_posts/MarkDown.md","hash":"8c3562c6ab9321720975465693fc01e8a4bbd921","modified":1589342681662},{"_id":"source/_posts/RTR-02.md","hash":"53f4d0ae139829c53432d6d4f30f6d7d411c0194","modified":1589342681662},{"_id":"source/_posts/RTR-03.md","hash":"430dc427fa05c06e7116f79bb81a9d46de835795","modified":1589342681663},{"_id":"source/_posts/RTR-04.md","hash":"14d4242b5cfb733aae625ee04f2b3b8cea46d4d6","modified":1589342681663},{"_id":"source/_posts/Shadertoy-01.md","hash":"b0d54f70ae8961ef5d90258c06b9cc32cd4a115d","modified":1589342681664},{"_id":"source/_posts/Shadertoy-02.md","hash":"e1050e7654a5f441a8ceed940f907bf8711b0883","modified":1589342681664},{"_id":"source/_posts/Shadertoy-04.md","hash":"30c196ac0790f1c33b36f2b2de3a9dbf1b0d4847","modified":1589342681665},{"_id":"source/_posts/Shadertoy-03.md","hash":"36800dd2cec7e28f579286940b786a44f1241cdd","modified":1589342681665},{"_id":"source/about/index.md","hash":"109085beaaa80ac89858b283a64f7c75d7e5bb12","modified":1589342681666},{"_id":"source/codes/RayTracing.glsl","hash":"61a33ddb5e13e56bfd8c310709b574af9f0413f1","modified":1589342681667},{"_id":"source/images/Directx11_01_04.png","hash":"0052e9ad131027bd6cafb7fecd39b659a8fa04e8","modified":1589342681678},{"_id":"source/images/Directx11_01_05.png","hash":"6b1b40a2dacd2b7ba5c7d34c60a673cdc3f19dda","modified":1589342681680},{"_id":"source/images/Directx11_01_10.png","hash":"b005a57ef020917b79ebd7e493603c94ae75382c","modified":1589342681691},{"_id":"source/images/Directx11_02_01.png","hash":"a3b3ff0fc22f6632cc5890c5f16bfbd4907f3898","modified":1589342681692},{"_id":"source/images/Directx11_02_03.png","hash":"9a7ed3d1ebe663bf75bc46a3f7227f1feb1b9f82","modified":1589342681695},{"_id":"source/images/RTR4.02.02.png","hash":"5bce3e8d0bd6d52c38070469dabe700b64c8fef0","modified":1589342681698},{"_id":"source/images/RTR4.02.03.png","hash":"4f9beca04bdd350565e7459ab2aca05757ae2603","modified":1589342681699},{"_id":"source/images/RTR4.02.08.png","hash":"7d604f56780803b73a2a5da619b393e50bc1ec6b","modified":1589342681700},{"_id":"source/images/RTR4.03.02.png","hash":"036c1cdd420fe777122b4d622b6e924585b0bb3f","modified":1589342681701},{"_id":"source/images/RTR4.03.03.png","hash":"0b78b250d7ab7538d4d8b18ea7f46cb3b8bd4fe3","modified":1589342681701},{"_id":"source/images/RTR4_02_01.png","hash":"740c1cf254c0a52d059395bf3090e29db2a5bd1a","modified":1589342681702},{"_id":"source/images/RTR4_04_01.png","hash":"7cee50f1aa9d80ce66d483792e8f42e45e37c2d4","modified":1589342681703},{"_id":"source/images/Shadertoy_01_03.png","hash":"bf463e70845a2173bbea77df371ce830edead612","modified":1589342681708},{"_id":"source/images/Shadertoy_01_04.png","hash":"be8a01095ebc2a370c96a941b6889717bc77b6e2","modified":1589342681708},{"_id":"source/images/Shadertoy_01_01.png","hash":"293ab6a2c444c4fa5067800cc8dac872684be1c2","modified":1589342681704},{"_id":"source/images/Shadertoy_01_05.png","hash":"a2d1bb31054910e1f6beae439fc86d9ce608978a","modified":1589342681710},{"_id":"source/images/Shadertoy_02_02.png","hash":"b614d00e723ead8287bcc4d7ac95c921dd4c5f86","modified":1589342681714},{"_id":"source/images/Shadertoy_02_03.png","hash":"a5f608cf195969663f15c3e22bb516fe56b75933","modified":1589342681715},{"_id":"source/images/Shadertoy_03_01.png","hash":"158215f64748fb97605b33f45f9c6931f37c318e","modified":1589342681716},{"_id":"source/images/Shadertoy_04_02.png","hash":"9328e6047dae7174d2b40205e6f104e9adcd8d59","modified":1589342681720},{"_id":"source/images/Shadertoy_04_09.png","hash":"6bf1fa157691b70618b60cbe737b82d69d22eb3e","modified":1589342681736},{"_id":"themes/hueman/.github/ISSUE_TEMPLATE.md","hash":"dc9c3910279551bc8515abf9fdf9d98d3b53f852","modified":1589342681737},{"_id":"themes/hueman/languages/ca.yml","hash":"d88625a06b434db3b0ed37b0d5f64ee31e91c077","modified":1589342681740},{"_id":"themes/hueman/languages/en.yml","hash":"3a93280606196c642eca66b58b149bf648d71724","modified":1589342681741},{"_id":"themes/hueman/languages/es.yml","hash":"92bbf2ebd70a08d5011e5c8c31597f2dd1ea9901","modified":1589342681742},{"_id":"themes/hueman/languages/fr.yml","hash":"8dd5712d1d3848732a30d53e65db42acfcfaa718","modified":1589342681742},{"_id":"themes/hueman/languages/hu.yml","hash":"1a503b6667515a4027850d3c645d34fa2b496411","modified":1589342681743},{"_id":"themes/hueman/languages/id.yml","hash":"dfd5d4ddf4797385093a8a569b71b18aa902e0c2","modified":1589342681744},{"_id":"themes/hueman/languages/ja.yml","hash":"64389f836e1965a55e85e57384b6b7276020f769","modified":1589342681745},{"_id":"themes/hueman/languages/ko.yml","hash":"e8dbf0a133dab72ea0ae5b98663f7086a83d4771","modified":1589342681746},{"_id":"themes/hueman/languages/pt-BR.yml","hash":"4caa8df5aba98b23672bbe7d70674f5f67744b95","modified":1589342681746},{"_id":"themes/hueman/languages/ru.yml","hash":"fb81066411e37a2472797d4d40a7c409d768d34a","modified":1589342681747},{"_id":"themes/hueman/languages/tr.yml","hash":"e28af4a5b366e116bbbfcd21b45c9c6996f6bfe7","modified":1589342681747},{"_id":"themes/hueman/languages/vi.yml","hash":"4f5d30e07dc3b32a605ffe2a546365157353836d","modified":1589342681748},{"_id":"themes/hueman/languages/zh-CN.yml","hash":"9f3b3b3a81d8965fb66b3b6028e566355f814d2d","modified":1589342681748},{"_id":"themes/hueman/languages/zh-TW.yml","hash":"88de26c2cb611a23a8671ea75b39884d65813117","modified":1589342681749},{"_id":"themes/hueman/layout/archive.ejs","hash":"8785477232088e09a75da88a0cdcb32fedf4f81f","modified":1589342681749},{"_id":"themes/hueman/layout/author.ejs","hash":"de99b00563d7c7b00cc7fd4e74e77c171891fbdc","modified":1589342681750},{"_id":"themes/hueman/layout/category.ejs","hash":"de99b00563d7c7b00cc7fd4e74e77c171891fbdc","modified":1589342681750},{"_id":"themes/hueman/layout/index.ejs","hash":"8785477232088e09a75da88a0cdcb32fedf4f81f","modified":1589342681768},{"_id":"themes/hueman/layout/layout.ejs","hash":"4376f9a13a19551ec72aa41b824c635f0a847c55","modified":1589342681769},{"_id":"themes/hueman/layout/page.ejs","hash":"5afddd6a45fa72beacec8d760487dfe8a667e622","modified":1589342681769},{"_id":"themes/hueman/layout/post.ejs","hash":"5afddd6a45fa72beacec8d760487dfe8a667e622","modified":1589342681772},{"_id":"themes/hueman/layout/tag.ejs","hash":"8785477232088e09a75da88a0cdcb32fedf4f81f","modified":1589342681778},{"_id":"themes/hueman/scripts/excerpt.js","hash":"61118ffd53158c6620010f6362752745f8372469","modified":1589342681784},{"_id":"themes/hueman/scripts/md5.js","hash":"39d9c264dc693505e5730f062e75b10f5c1bfa24","modified":1589342681784},{"_id":"themes/hueman/scripts/meta.js","hash":"2e5ac0cb9c90c072ca4b33e88f1892e954935ab7","modified":1589342681785},{"_id":"themes/hueman/scripts/thumbnail.js","hash":"1fe763bf492813dd51276d48dd61a1855b40a53e","modified":1589342681785},{"_id":"source/images/Directx11_01_01.png","hash":"cc014203688ba643f0229962dd3bf0e3e895f068","modified":1589342681670},{"_id":"source/images/Directx11_02_02.png","hash":"53785c8bf122f60b0694fe54033fe60723eb71fa","modified":1589342681694},{"_id":"source/images/Shadertoy_04_06.png","hash":"55e603875038a0484f1b88a0f429c3464d9b813f","modified":1589342681730},{"_id":"source/images/Shadertoy_04_08.png","hash":"55488cc0809ed790e28531dfda91d1e80fc69dd4","modified":1589342681735},{"_id":"source/images/DirectX11.png","hash":"8f0c69da1d0b4a50bd1e89c7324d70869a92e37e","modified":1589342681669},{"_id":"source/images/Shadertoy_04_04.png","hash":"72e70083e833933173469c7bbe4c8d4ccf7669e8","modified":1589342681725},{"_id":"themes/hueman/layout/comment/changyan.ejs","hash":"1354c7e54f8fb29084b773dd5c0872ef63c2da85","modified":1589342681751},{"_id":"themes/hueman/layout/comment/counter.ejs","hash":"9b6eaf3c6da487012483a6d930d0b50ac4f1a307","modified":1589342681752},{"_id":"themes/hueman/layout/comment/disqus.ejs","hash":"84988da295ab8c509e24299c2c857d707cf78f77","modified":1589342681753},{"_id":"themes/hueman/layout/comment/duoshuo.ejs","hash":"adc024b7205e934e64c98a5b912c41117a4425bd","modified":1589342681753},{"_id":"themes/hueman/layout/comment/facebook.ejs","hash":"6a53104fc01fd4a7a34b46c2828e76d02cacb0dd","modified":1589342681754},{"_id":"themes/hueman/layout/comment/gitalk.ejs","hash":"370094914d8fa8b53c8cae027f96111fc0bc5e8e","modified":1589342681755},{"_id":"themes/hueman/layout/comment/index.ejs","hash":"fc12a38a3d9d92def1b86ee066b3521194d43707","modified":1589342681756},{"_id":"themes/hueman/layout/comment/isso.ejs","hash":"b8da0b50fad39ed39f6674c30112fc0b53acd07b","modified":1589342681756},{"_id":"themes/hueman/layout/comment/livere.ejs","hash":"d2d0d8113a5a7d2cddf1d8ce067e07d40874e56c","modified":1589342681757},{"_id":"themes/hueman/layout/comment/scripts.ejs","hash":"6c0fb0de033842e3344158bc5b130194b6768156","modified":1589342681757},{"_id":"themes/hueman/layout/comment/valine.ejs","hash":"5ebbe64d73c91a08b3fdbe71f6cbd69c05b0feef","modified":1589342681758},{"_id":"themes/hueman/layout/comment/youyan.ejs","hash":"e5f5561a26343013e57a1f5c049c4f22f878d013","modified":1589342681758},{"_id":"themes/hueman/layout/common/archive.ejs","hash":"a2e1599e9e95ebc7d4dad3cab0a6233d4e4fc191","modified":1589342681759},{"_id":"themes/hueman/layout/common/article.ejs","hash":"6ed86bbc71647ab725de16ce34951ca4cecd849c","modified":1589342681760},{"_id":"themes/hueman/layout/common/content-title.ejs","hash":"fd32d9ed053e54656b0bd4604a6a25cd522232b7","modified":1589342681760},{"_id":"themes/hueman/layout/common/footer.ejs","hash":"1a18f070934ca300a4ae9672f975b6f9aa83b2f0","modified":1589342681761},{"_id":"themes/hueman/layout/common/head.ejs","hash":"8724ca0222477f216a3be73bb1235f28da63cd09","modified":1589342681761},{"_id":"themes/hueman/layout/common/header.ejs","hash":"a27f027fc60d49ca84381a08c7102aa7d3118ec4","modified":1589342681762},{"_id":"themes/hueman/layout/common/scripts.ejs","hash":"271ad89a94bbced9f3f7377c145d86b62df0fee9","modified":1589342681766},{"_id":"themes/hueman/layout/common/sidebar.ejs","hash":"d9f3f3a9d5b02306d0c40eca6ac8b6450f760e36","modified":1589342681767},{"_id":"themes/hueman/layout/common/summary.ejs","hash":"9507cd43d3638ec69052c144715b37fa0bbe9207","modified":1589342681767},{"_id":"themes/hueman/layout/common/thumbnail.ejs","hash":"24cafe46466aa4b0b0f93e0028e5c977771ea3e5","modified":1589342681768},{"_id":"themes/hueman/layout/plugin/baidu-analytics.ejs","hash":"dc075c744e866c3cea8460439953fa2a073d6475","modified":1589342681770},{"_id":"themes/hueman/layout/plugin/google-analytics.ejs","hash":"758b4312ad55151bafd966c9c5c1a89095352360","modified":1589342681770},{"_id":"themes/hueman/layout/plugin/scripts.ejs","hash":"6db533bb9d86cccdb1a855818d9c24bd8f268195","modified":1589342681771},{"_id":"themes/hueman/layout/plugin/statcounter.ejs","hash":"e2fe080dc8f62cba6791bef3d4ecb6454024f2c4","modified":1589342681771},{"_id":"themes/hueman/layout/pwa/index.ejs","hash":"0ca08d5a308a82fbf372821c4f0fdef0df98af78","modified":1589342681772},{"_id":"themes/hueman/layout/search/baidu.ejs","hash":"46515988503a8b8dd07d0cf3ccabf519b4fad2d1","modified":1589342681773},{"_id":"themes/hueman/layout/search/index.ejs","hash":"1b232e45234638a08cdc34d33cd7378636649822","modified":1589342681773},{"_id":"themes/hueman/layout/search/swiftype.ejs","hash":"cce9c44180d9490f45b30b8f052ac82675a9d66a","modified":1589342681774},{"_id":"themes/hueman/layout/search/insight.ejs","hash":"21ec59e4534ac2417d6b215b6cfe3825245ad340","modified":1589342681774},{"_id":"themes/hueman/layout/share/addtoany.ejs","hash":"b79f714da69c121729a136df0c94c09a85966d44","modified":1589342681775},{"_id":"themes/hueman/layout/share/bdshare.ejs","hash":"015715441fc4075e8c8d8c51f523634c19296bc7","modified":1589342681776},{"_id":"themes/hueman/layout/share/default.ejs","hash":"9a12d26f8d01557f69ca403a4b6f96fab7b45bd7","modified":1589342681776},{"_id":"themes/hueman/layout/share/index.ejs","hash":"a0d5e32c68e1e6d3f2f954420bbb48675736b895","modified":1589342681777},{"_id":"themes/hueman/layout/share/jiathis.ejs","hash":"038b7d02aa765f6eb222c23356246ee3594b2965","modified":1589342681777},{"_id":"themes/hueman/layout/widget/archive.ejs","hash":"4bf2c1433166017450a3e7d265570b34d59195eb","modified":1589342681778},{"_id":"themes/hueman/layout/widget/catalog.ejs","hash":"02c7fe79b53e34f8aa3854c4c205ecfd7caffd6c","modified":1589342681779},{"_id":"themes/hueman/layout/widget/category.ejs","hash":"4f39c49773590a8c854aab6c09623afb1de865b5","modified":1589342681779},{"_id":"themes/hueman/layout/widget/links.ejs","hash":"a979a257a0e8720de8c052233840c1ddde95ea37","modified":1589342681780},{"_id":"themes/hueman/layout/widget/recent_posts.ejs","hash":"dd092bbf28104482210b4c4a734e551f7536f525","modified":1589342681781},{"_id":"themes/hueman/layout/widget/sticky_posts.ejs","hash":"c62a9abcf3d0f2941346f433510eb9bd843ee8c1","modified":1589342681781},{"_id":"themes/hueman/layout/widget/tag.ejs","hash":"49c61ba1e57a76ab03053ef1b885ddeaa121c7ce","modified":1589342681782},{"_id":"themes/hueman/layout/widget/tagcloud.ejs","hash":"744f0a0a9249745c7afd8abb0faba2cdb5b6811c","modified":1589342681783},{"_id":"themes/hueman/source/css/_extend.styl","hash":"8476764f75db59f94fbabebc5ddbf8fd4523c453","modified":1589342681786},{"_id":"themes/hueman/source/css/_responsive.styl","hash":"0e41183083909fa8d0b9cd6d7ebc5bcacded1b8f","modified":1589342681838},{"_id":"themes/hueman/source/css/_variables.styl","hash":"bd40db9c703ec967219e0ea1ec1d9ee7cff47def","modified":1589342681838},{"_id":"themes/hueman/source/css/style.styl","hash":"99623727296205ab418b220529a17bdd18ffa56c","modified":1589342681842},{"_id":"themes/hueman/source/js/insight.js","hash":"154c023c13d913984e9f70e22affea1ee8abe444","modified":1589342681842},{"_id":"themes/hueman/source/js/main.js","hash":"ae83bd5df9da13a0dcc4a85d89f8bfe7e3ac93b7","modified":1589342681843},{"_id":"source/images/Directx11_01_03.png","hash":"d2c764be23df34013afd2d35c710e19cc8047237","modified":1589342681677},{"_id":"source/images/Directx11_01_08.png","hash":"a682daf9d91e9616644bc8763b446ef96f7f7b1b","modified":1589342681687},{"_id":"source/images/Shadertoy_01_02.gif","hash":"3bba3258c6a87d54043e2c05a2f014e953ed8b55","modified":1589342681706},{"_id":"source/images/Shadertoy_04_03.png","hash":"f986ee702430b782218959479e0c5864e0558603","modified":1589342681722},{"_id":"source/images/Directx11_01_07.png","hash":"47f1b9681f5339ca15caac13a81cc2e7e58e3679","modified":1589342681685},{"_id":"source/images/Directx11_02_04.png","hash":"0ba83d53db1f884665d4cbcd7f462fd306c72366","modified":1589342681697},{"_id":"themes/hueman/layout/common/post/author.ejs","hash":"3e0a968ec92cc4d464d705190615f5eed649875a","modified":1589342681762},{"_id":"themes/hueman/layout/common/post/date.ejs","hash":"79c2a591274f863a78dcadaaf63f087ad7b9e7e1","modified":1589342681763},{"_id":"themes/hueman/layout/common/post/gallery.ejs","hash":"1ccdc66206e84668fa1f0d2440a8ed983aa321fd","modified":1589342681764},{"_id":"themes/hueman/layout/common/post/ld_json.ejs","hash":"0bf468a15025e2d8bd5b9209a05a9f32b61548b9","modified":1589342681764},{"_id":"themes/hueman/layout/common/post/nav.ejs","hash":"f7a755a93abed84337f2519eae788f20a88c4bf3","modified":1589342681765},{"_id":"themes/hueman/layout/common/post/tag.ejs","hash":"7df16851b35da0ea09f7323bdbfb977198823f4c","modified":1589342681765},{"_id":"themes/hueman/layout/common/post/title.ejs","hash":"e164edee924be00641013f0fd4e53f55b51f90a8","modified":1589342681766},{"_id":"themes/hueman/source/css/_highlight/agate.styl","hash":"c01db6c4e7648b217048a8deefeee189688a9290","modified":1589342681786},{"_id":"themes/hueman/source/css/_highlight/androidstudio.styl","hash":"b0923fe15d0b5eb24d3c6236cb2fc30ee14a4c56","modified":1589342681787},{"_id":"themes/hueman/source/css/_highlight/arduino-light.styl","hash":"591962bfc758a521b4cb907750c19a1a2423b4d5","modified":1589342681787},{"_id":"themes/hueman/source/css/_highlight/arta.styl","hash":"3bc322455f657aa29f455f91009034af08cdc65c","modified":1589342681788},{"_id":"themes/hueman/source/css/_highlight/ascetic.styl","hash":"ca087a3c70998c7ac6b0b42d5cf7a653b8707591","modified":1589342681789},{"_id":"themes/hueman/source/css/_highlight/atelier-cave-dark.styl","hash":"a6b1960d8a3b39d035e06ce92af4f00a259b5c56","modified":1589342681789},{"_id":"themes/hueman/source/css/_highlight/atelier-cave-light.styl","hash":"f47de0b9d66617728f68096ed48371dd6bb9e67a","modified":1589342681790},{"_id":"themes/hueman/source/css/_highlight/atelier-dune-dark.styl","hash":"68021a92fd7d6895426d0cc7f0929aa95633d742","modified":1589342681790},{"_id":"themes/hueman/source/css/_highlight/atelier-dune-light.styl","hash":"657fe215931fd06e21b56374df699a94890f7ab4","modified":1589342681791},{"_id":"themes/hueman/source/css/_highlight/atelier-estuary-dark.styl","hash":"6c051f034c229c49ffc9a2ec96c032441b0c6586","modified":1589342681792},{"_id":"themes/hueman/source/css/_highlight/atelier-estuary-light.styl","hash":"2b416a0567a53aa0fa8898b196ddd44315c1a5f3","modified":1589342681793},{"_id":"themes/hueman/source/css/_highlight/atelier-forest-dark.styl","hash":"15559324ee3a5f9bf6724ec9606f6f2e16cdc24d","modified":1589342681793},{"_id":"themes/hueman/source/css/_highlight/atelier-forest-light.styl","hash":"8d7c7242974aa2454fa792c5d7a47c5f9632355a","modified":1589342681794},{"_id":"themes/hueman/source/css/_highlight/atelier-heath-dark.styl","hash":"bf62cafe316eb874f1f43679957dc3add4fbea34","modified":1589342681794},{"_id":"themes/hueman/source/css/_highlight/atelier-heath-light.styl","hash":"c1db353e8613607580d40b12ddc162d029560576","modified":1589342681795},{"_id":"themes/hueman/source/css/_highlight/atelier-lakeside-dark.styl","hash":"64ab6ab93a092a890d3d0fdeb23e4b6a2d0f2887","modified":1589342681796},{"_id":"themes/hueman/source/css/_highlight/atelier-lakeside-light.styl","hash":"8659eaae6a0c2e00b4b9199803e50adf4ff0128d","modified":1589342681796},{"_id":"themes/hueman/source/css/_highlight/atelier-plateau-dark.styl","hash":"8a6c187afcd60152306c003e1a5903e57d9428dd","modified":1589342681797},{"_id":"themes/hueman/source/css/_highlight/atelier-plateau-light.styl","hash":"96181544eeadc5b0749229f11607e7c01f81e078","modified":1589342681797},{"_id":"themes/hueman/source/css/_highlight/atelier-savanna-dark.styl","hash":"5261a100e84cf34f4752c24dfaddfa05c7be96f7","modified":1589342681798},{"_id":"themes/hueman/source/css/_highlight/atelier-savanna-light.styl","hash":"8a5207a0c30262a0bf5e1a41411a306f7a89a7e7","modified":1589342681798},{"_id":"themes/hueman/source/css/_highlight/atelier-seaside-dark.styl","hash":"434b7f0bdd5f91bf79d5b4ca46820db4a8e10166","modified":1589342681799},{"_id":"themes/hueman/source/css/_highlight/atelier-seaside-light.styl","hash":"08e2df313c272d5c70c93e713639663c168180d0","modified":1589342681799},{"_id":"themes/hueman/source/css/_highlight/atelier-sulphurpool-dark.styl","hash":"fa0cccd0f0dc015218cf8c1bba0b53c8c9383135","modified":1589342681800},{"_id":"themes/hueman/source/css/_highlight/atelier-sulphurpool-light.styl","hash":"add3d88c9d12567dcfae7a8e49984d119fc72227","modified":1589342681801},{"_id":"themes/hueman/source/css/_highlight/brown-paper.styl","hash":"d14846542a26b75fd26df5b5df6c5493733f73f6","modified":1589342681801},{"_id":"themes/hueman/source/css/_highlight/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1589342681802},{"_id":"themes/hueman/source/css/_highlight/codepen-embed.styl","hash":"7432ce9edb047b6382d28c82054a7e2a77e476c3","modified":1589342681803},{"_id":"themes/hueman/source/css/_highlight/color-brewer.styl","hash":"9c4905eab730d0b389e6972e907057577f7e25f1","modified":1589342681804},{"_id":"themes/hueman/source/css/_highlight/dark.styl","hash":"df4c1dc05567ad0812d0cd3133cb2a2a5fd23c04","modified":1589342681804},{"_id":"themes/hueman/source/css/_highlight/darkula.styl","hash":"3c943561a885092286ec8db14e9177036bf8d21f","modified":1589342681805},{"_id":"themes/hueman/source/css/_highlight/docco.styl","hash":"7bd3389ce16d20488ab336d557056cc703c921c7","modified":1589342681806},{"_id":"themes/hueman/source/css/_highlight/far.styl","hash":"5989aea14ccd0153d17ee19b3e125dae06c75f3c","modified":1589342681807},{"_id":"themes/hueman/source/css/_highlight/foundation.styl","hash":"28c59a31467c33bd51cbf3b6085782c2a724ff6c","modified":1589342681807},{"_id":"themes/hueman/source/css/_highlight/github-gist.styl","hash":"71f4b0fca91a587e6eba15a5306dca963bb8f441","modified":1589342681808},{"_id":"themes/hueman/source/css/_highlight/googlecode.styl","hash":"7f5082ae008925a23eb713f160773fe647eb3ff7","modified":1589342681809},{"_id":"themes/hueman/source/css/_highlight/github.styl","hash":"a84eb710b302006120c3e7f8ca18f9e6fbc231c3","modified":1589342681809},{"_id":"themes/hueman/source/css/_highlight/grayscale.styl","hash":"c83804abe39faebd80f8f4ff64fbd7137674cb1c","modified":1589342681810},{"_id":"themes/hueman/source/css/_highlight/highlightjs.styl","hash":"fd796a58c5d4590cda67c998187933788d45f30a","modified":1589342681810},{"_id":"themes/hueman/source/css/_highlight/hopscotch.styl","hash":"7ec8d75a9c9d58f65868ea64289873302d3fad5e","modified":1589342681811},{"_id":"themes/hueman/source/css/_highlight/hybrid.styl","hash":"d3ee1bcefc94f5f87a2b76a689f4c31594501d07","modified":1589342681811},{"_id":"themes/hueman/source/css/_highlight/idea.styl","hash":"e284c1760e8da0848f56cd5601d867ceeb0192d7","modified":1589342681812},{"_id":"themes/hueman/source/css/_highlight/index.styl","hash":"be660dbee7c8840d80654febaa97745a2f7f80eb","modified":1589342681813},{"_id":"themes/hueman/source/css/_highlight/ir-black.styl","hash":"c59db73998af32ce8419a5d2d335bcc9cfbaae45","modified":1589342681813},{"_id":"themes/hueman/source/css/_highlight/kimbie.dark.styl","hash":"3b998c640eeb2c6192fee24bc78b4137de475dd7","modified":1589342681814},{"_id":"themes/hueman/source/css/_highlight/kimbie.light.styl","hash":"e901738455ec9a1bddde7b62bbd8595de6033e1e","modified":1589342681814},{"_id":"themes/hueman/source/css/_highlight/magula.styl","hash":"ab179306c12a1cf2949482beaca328e379ef034a","modified":1589342681815},{"_id":"themes/hueman/source/css/_highlight/mono-blue.styl","hash":"14fb8678739b77f35771b6d63101ddbf1e7a9fbc","modified":1589342681815},{"_id":"themes/hueman/source/css/_highlight/monokai-sublime.styl","hash":"32955f699687b5fc2e4072804cb90925912d3c7c","modified":1589342681816},{"_id":"themes/hueman/source/css/_highlight/monokai.styl","hash":"8489fc71bedefa8f271808126296fce6381f9e04","modified":1589342681817},{"_id":"themes/hueman/source/css/_highlight/obsidian.styl","hash":"8145db8ec349548f09d91d7a05c00c83ff84d146","modified":1589342681817},{"_id":"themes/hueman/source/css/_highlight/paraiso-dark.styl","hash":"50f1cee8a5b3b165b4184ead0a99dc564b62ef4f","modified":1589342681818},{"_id":"themes/hueman/source/css/_highlight/paraiso-light.styl","hash":"e428e8202b01e83b0f018a96058d806e7f4c76bf","modified":1589342681819},{"_id":"themes/hueman/source/css/_highlight/pojoaque.jpg","hash":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1589342681819},{"_id":"themes/hueman/source/css/_highlight/pojoaque.styl","hash":"d9f4b35c9f6115029600a8a023b559013e2b4e75","modified":1589342681820},{"_id":"themes/hueman/source/css/_highlight/railscasts.styl","hash":"1ff800d9b6de464fafe591682cc48bf983202758","modified":1589342681821},{"_id":"themes/hueman/source/css/_highlight/rainbow.styl","hash":"516c7080d64b12730357358dee2adc42c43c4516","modified":1589342681822},{"_id":"themes/hueman/source/css/_highlight/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1589342681822},{"_id":"themes/hueman/source/css/_highlight/solarized-dark.styl","hash":"577458d1f6c02bc42e312066bf7dd7e427cab057","modified":1589342681823},{"_id":"themes/hueman/source/css/_highlight/school-book.styl","hash":"186c37e9c39e65aa291cce3317e35904693598d1","modified":1589342681823},{"_id":"themes/hueman/source/css/_highlight/solarized-light.styl","hash":"bb04944fc06c12ecd7b56ad933dbedde60c2259a","modified":1589342681824},{"_id":"themes/hueman/source/css/_highlight/sunburst.styl","hash":"482bbb2bc461b22e9d6ce55f0f84767e1cfae99a","modified":1589342681825},{"_id":"themes/hueman/source/css/_highlight/tomorrow-night-blue.styl","hash":"eeafa86697c857c4e9a84ad48c0d56a7154997a3","modified":1589342681826},{"_id":"themes/hueman/source/css/_highlight/tomorrow-night-bright.styl","hash":"f3cd5ed391d40265e36fcd9f7daced52773fb886","modified":1589342681827},{"_id":"themes/hueman/source/css/_highlight/tomorrow-night-eighties.styl","hash":"1cd947f3d414fa5c1435caea509f27c99f6dc5b3","modified":1589342681828},{"_id":"themes/hueman/source/css/_highlight/tomorrow-night.styl","hash":"b2a175caa23631f764b2f6fe2bac9739f5f5e078","modified":1589342681828},{"_id":"themes/hueman/source/css/_highlight/tomorrow.styl","hash":"502335f0fac07ed74ca78207bcf3ef8dd2252cf6","modified":1589342681829},{"_id":"themes/hueman/source/css/_highlight/vs.styl","hash":"14fbb0c43af440a290280b26968c8a5c0786b27f","modified":1589342681830},{"_id":"themes/hueman/source/css/_highlight/xcode.styl","hash":"5fa8999c7f807c1aae29c7a1cdf681678576fb69","modified":1589342681830},{"_id":"themes/hueman/source/css/_highlight/zenburn.styl","hash":"6908313d2666d31fc9d8658fd7e8dda3de2bb596","modified":1589342681831},{"_id":"themes/hueman/source/css/_partial/article.styl","hash":"dc4f2dfb91ee851d0ba2b2c59073ef10e53ce91e","modified":1589342681832},{"_id":"themes/hueman/source/css/_partial/archive.styl","hash":"46aa36ef93ee77bfa97adad6ab2530a1057a1596","modified":1589342681832},{"_id":"themes/hueman/source/css/_partial/assets.styl","hash":"c42627622550f02395087c53a1a193f162fded65","modified":1589342681833},{"_id":"themes/hueman/source/css/_partial/comment.styl","hash":"850f1f84987159da6fa2efdfa95cc82d0a2e59cd","modified":1589342681834},{"_id":"themes/hueman/source/css/_partial/footer.styl","hash":"c5ab092de0661c344cb5176580443f126d6e31cc","modified":1589342681834},{"_id":"themes/hueman/source/css/_partial/header.styl","hash":"64e4b94f1e88d795c8866d261856680ca6faee2a","modified":1589342681835},{"_id":"themes/hueman/source/css/_partial/insight.styl","hash":"b29d88a9411f06974aa67381a3f3f39fb3b69feb","modified":1589342681836},{"_id":"themes/hueman/source/css/_partial/nav.styl","hash":"b2941a6a171d2bfb3000be71664c04cc2a2c5964","modified":1589342681836},{"_id":"themes/hueman/source/css/_partial/sidebar.styl","hash":"7533eddd2aba59663d21b14d248e485e3ca173d2","modified":1589342681837},{"_id":"themes/hueman/source/css/images/logo-header.png","hash":"00a0eb09470a695b07faeae2c827e49cdec868d7","modified":1589342681839},{"_id":"themes/hueman/source/css/images/opacity-10.png","hash":"bbc979866c5b50e8adb348419154b28b1ff44d78","modified":1589342681839},{"_id":"themes/hueman/source/css/images/s-left.png","hash":"c8cac4f4e3492606fab93196364bd0f87d93bb98","modified":1589342681840},{"_id":"themes/hueman/source/css/images/thumb-default-small.png","hash":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1589342681840},{"_id":"themes/hueman/source/css/images/thumb-default.png","hash":"2d0ba175d958d342494241c616a74d37f48059fb","modified":1589342681841},{"_id":"themes/hueman/source/libs/justified-gallery/jquery.justifiedGallery.min.js","hash":"1c7fd3bd976f671ba396ad4dbbb7157006243bf5","modified":1589342681857},{"_id":"themes/hueman/source/libs/justified-gallery/justifiedGallery.min.css","hash":"45fa2fad51cecfc41107dbd4637450b746a7cbc3","modified":1589342681857},{"_id":"themes/hueman/source/libs/source-code-pro/styles.css","hash":"6335d719343cca455152ad71a1aaed9868339236","modified":1589342681886},{"_id":"themes/hueman/source/libs/titillium-web/styles.css","hash":"5780e94a2a38ffa02322edaa780cb58c3199efa7","modified":1589342681892},{"_id":"source/images/Shadertoy_04_01.png","hash":"3c9f5347bcc655caa836e48c2891a419bd945565","modified":1589342681719},{"_id":"source/images/Shadertoy_04_07.png","hash":"4ee4348d7b7c2820ace50c314f21f8cc8b7c4223","modified":1589342681733},{"_id":"source/images/Directx11_01_06.png","hash":"74c732587144ca4d1041a66c384929cd7783e991","modified":1589342681682},{"_id":"source/images/Shadertoy_04_05.png","hash":"d615128d2f8a59bfee19b4773f99eb683ef464b4","modified":1589342681728},{"_id":"themes/hueman/source/libs/font-awesome/css/font-awesome.css","hash":"bf188c224998b995d0119cfd18fade22e53f573c","modified":1589342681844},{"_id":"themes/hueman/source/libs/font-awesome/css/font-awesome.min.css","hash":"bd7c2763e15e568bdccc85e38432d79f65f8d9a1","modified":1589342681845},{"_id":"themes/hueman/source/libs/lightgallery/css/lg-fb-comment-box.css","hash":"10c9630e41bb8d6bb7f75a3bfe8cdb33451ed7ba","modified":1589342681858},{"_id":"themes/hueman/source/libs/lightgallery/css/lg-fb-comment-box.css.map","hash":"5281d2cfb0ef278940c4860ea9aa7ef86d3dbc8d","modified":1589342681859},{"_id":"themes/hueman/source/libs/lightgallery/css/lg-fb-comment-box.min.css","hash":"05830fadb8454f39dcc98c8686eb4d5c24b71fc0","modified":1589342681859},{"_id":"themes/hueman/source/libs/lightgallery/css/lg-transitions.css","hash":"2866c3f1eda31ed34485ff3511bcfb706d78ac56","modified":1589342681860},{"_id":"themes/hueman/source/libs/lightgallery/css/lg-transitions.css.map","hash":"6ee19f99bca3ecf2fa0d6f07fb5c200db07ddd11","modified":1589342681861},{"_id":"themes/hueman/source/libs/lightgallery/css/lg-transitions.min.css","hash":"5c22e2073a4c96d6212c72135391b599e8d1359f","modified":1589342681862},{"_id":"themes/hueman/source/libs/lightgallery/css/lightgallery.css","hash":"d26b528a13ee1ef245bdb0aa3db149be3fe9cba6","modified":1589342681863},{"_id":"themes/hueman/source/libs/lightgallery/css/lightgallery.css.map","hash":"91788030e3c7107b6b4bf50a82d4309368850488","modified":1589342681864},{"_id":"themes/hueman/source/libs/lightgallery/css/lightgallery.min.css","hash":"c9a2e19c932b56f4a2ce30c98910d10b74edb38a","modified":1589342681865},{"_id":"themes/hueman/source/libs/lightgallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1589342681866},{"_id":"themes/hueman/source/libs/lightgallery/fonts/lg.svg","hash":"3480f00d284c812d623ed16a9e0ead3fb964c72e","modified":1589342681866},{"_id":"themes/hueman/source/libs/lightgallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1589342681867},{"_id":"themes/hueman/source/libs/lightgallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1589342681868},{"_id":"themes/hueman/source/libs/lightgallery/img/loading.gif","hash":"607810444094b8619fa4efa6273bc2a7e38dd4b4","modified":1589342681869},{"_id":"themes/hueman/source/libs/lightgallery/img/video-play.png","hash":"3ea484cdc04d2e4547f80cbf80001dcf248c94ef","modified":1589342681870},{"_id":"themes/hueman/source/libs/lightgallery/img/vimeo-play.png","hash":"6190254f2804904a4a1fa1eb390dfd334e416992","modified":1589342681871},{"_id":"themes/hueman/source/libs/lightgallery/img/youtube-play.png","hash":"fea6df9d9d43151f9c9d15f000adb30eb3e26fc4","modified":1589342681872},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-autoplay.js","hash":"ba52bd55c0ab647e277c42b0e48a0ac25cbd3099","modified":1589342681873},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-autoplay.min.js","hash":"44203a1490749aff6aba9784868b6c888d3fb86e","modified":1589342681873},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-fullscreen.js","hash":"6369e9704550f4207fa798dc6018da1d259fd318","modified":1589342681874},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-fullscreen.min.js","hash":"a5c468d260e3a8e68c9026aa2b5f31ce1860b8bf","modified":1589342681875},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-hash.js","hash":"8a026dc31f912cbd3b8a110bb87984b372661f65","modified":1589342681875},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-hash.min.js","hash":"fbdbcb46ae9fd668ba5e4dce5635c040359e3359","modified":1589342681876},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-pager.js","hash":"562f883ba3a5e8ea570fd5d0c40afe527938c026","modified":1589342681877},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-pager.min.js","hash":"ec662f97ed5a15c2bd8cf87d5c93cd9a6b4df07a","modified":1589342681877},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-share.js","hash":"b000585441e9bff2f5b7c538d623b698d48049a6","modified":1589342681878},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-share.min.js","hash":"afe725882964c87a148ac6ab54955cb0da0974c4","modified":1589342681878},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-thumbnail.js","hash":"99fe3cc63161f0d678360a939fbd54c5d1c11eeb","modified":1589342681879},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-thumbnail.min.js","hash":"e570807e2786a0acb393c1195c820a660312fffe","modified":1589342681880},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-video.js","hash":"11c8509a3e398cb8c2a32ff559ccdda6d9d71740","modified":1589342681880},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-video.min.js","hash":"050e7684bfbb133bed5375938fe0021f1fa88f7f","modified":1589342681881},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-zoom.js","hash":"69a127964e508699f5f13467dd1b58fbf04bcca9","modified":1589342681882},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-zoom.min.js","hash":"8daabc26ceadc43741904b99db7e01bfababbd04","modified":1589342681882},{"_id":"themes/hueman/source/libs/lightgallery/js/lightgallery.js","hash":"6d424527be45ff4deedd198e195fdeb74f1c6567","modified":1589342681883},{"_id":"themes/hueman/source/libs/lightgallery/js/lightgallery.min.js","hash":"dc9c6447d3574fcba3868c35bb48e0bed9be6b7e","modified":1589342681884},{"_id":"themes/hueman/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","hash":"942addaec4d3a60af33947a84a3d85f926015947","modified":1589342681885},{"_id":"themes/hueman/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","hash":"b0e0bb5ef78db8b15d430d0b9be9d4329289a310","modified":1589342681885},{"_id":"themes/hueman/source/libs/titillium-web/fonts/7XUFZ5tgS-tD6QamInJTcSo_WB_cotcEMUw1LsIE8mM.woff2","hash":"6d17eac7fcc2866f10d1f2725a08ab749a6e978d","modified":1589342681887},{"_id":"themes/hueman/source/libs/titillium-web/fonts/7XUFZ5tgS-tD6QamInJTcZSnX671uNZIV63UdXh3Mg0.woff2","hash":"78029561e4c2ec565ea11c3f5bbd052b018af8a6","modified":1589342681888},{"_id":"themes/hueman/source/libs/titillium-web/fonts/anMUvcNT0H1YN4FII8wpr4-67659ICLY8bMrYhtePPA.woff2","hash":"4e5557954ec161edc03b6f971ddefee6179c1305","modified":1589342681889},{"_id":"themes/hueman/source/libs/titillium-web/fonts/anMUvcNT0H1YN4FII8wpr46gJz9aNFrmnwBdd69aqzY.woff2","hash":"1454a4753468b607c23deac9f5438cd0ed5cb35d","modified":1589342681889},{"_id":"themes/hueman/source/libs/titillium-web/fonts/anMUvcNT0H1YN4FII8wpr9INifKjd1RJ3NxxEi9Cy2w.woff2","hash":"1758c64c8acec4497735ccb5336b1a518d24024c","modified":1589342681890},{"_id":"themes/hueman/source/libs/titillium-web/fonts/anMUvcNT0H1YN4FII8wpr_SNRT0fZ5CX-AqRkMYgJJo.woff2","hash":"e2e2993940fc54ed41f26e39257fdbd824c05e81","modified":1589342681891},{"_id":"source/images/Directx11_01_09.png","hash":"17ed6bd2e62fb75776b3485c250c546c1a6f04cd","modified":1589342681690},{"_id":"source/images/Shadertoy_02_01.png","hash":"4ad9e3e30e0e2f4428be1f39ff325e60c2a90f7e","modified":1589342681713},{"_id":"themes/hueman/source/libs/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1589342681854},{"_id":"themes/hueman/source/libs/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1589342681855},{"_id":"themes/hueman/source/libs/jquery/3.3.1/jquery.min.js","hash":"0c3192b500a4fd550e483cf77a49806a5872185b","modified":1589342681856},{"_id":"themes/hueman/source/libs/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1589342681847},{"_id":"themes/hueman/source/libs/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1589342681848},{"_id":"themes/hueman/source/libs/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1589342681853},{"_id":"source/images/Directx11_01_02.png","hash":"118895158be0e194969bf90aa0b86701acea60b9","modified":1589342681675},{"_id":"themes/hueman/source/libs/font-awesome/fonts/fontawesome-webfont.svg","hash":"964e8dac2cee79c4b49b5bc300675773f6518812","modified":1589342681850}],"Category":[{"name":"Directx11","_id":"cka4xpxi800038st1pt8p4p87"},{"name":"Real Time Rendering","_id":"cka4xpxin000d8st1rtinm0w5"},{"name":"Shader","_id":"cka4xpxiz000s8st1ghndkebh"}],"Data":[],"Page":[{"_content":"Null","source":"about/index.md","raw":"Null","date":"2020-05-13T04:04:41.666Z","updated":"2020-05-13T04:04:41.666Z","path":"about/index.html","title":"","comments":1,"layout":"page","_id":"cka4xpxi300018st18uyzl36q","content":"<p>Null</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Null</p>\n"}],"Post":[{"title":"Directx11 - 01.配置环境","date":"2018-07-29T13:51:03.000Z","thumbnail":"/images/Directx11_01_10.png","_content":"## 选择教程：\n我跟的是[Braynzar Soft Tutorials](https://www.braynzarsoft.net/viewtutorial/q16390-braynzar-soft-directx-11-tutorials)\n之前有跟过[DirectXTutorial.com](http://www.directxtutorial.com/LessonList.aspx?listid=11)，讲的挺好的，但是到一半就要付费了。\n也看到过很多推荐说龙书或者dx自带的教程，但是因为我对C++不是很熟，首要的要求是教程的代码可以直接跑起来的，所以最后选了这个。\n\n## 安装软件：\n- Visual Studio 2017 [Download here](https://visualstudio.microsoft.com/zh-hans/downloads/)\n- DirectX SDK June 2010 [Download here](https://www.microsoft.com/en-us/download/details.aspx?id=6812)\n如果安装dx的时候遇到**s1023**的问题，是因为电脑上已经安装了Microsoft Visual C++ 2010 Redistributable，需要先卸载才能成功安装dx\n![](/images/Directx11_01_01.png)\n![](/images/Directx11_01_02.png)\n\n## 新建项目：\n菜单栏File -> New -> Project\n![](/images/Directx11_01_03.png)\n勾选Empty Project\n![](/images/Directx11_01_04.png)\n在Project的名字（Demo）上右键add->new item，新建main.cpp和Effects.fx两个文件\n![](/images/Directx11_01_05.png)\n详细代码从教程最下面的[Heres the full code](https://www.braynzarsoft.net/viewtutorial/q16390-5-color)复制\n\n## 配置项目：\n在Project的名字（Demo）上右键Properties进行配置\n1. 找到自己安装dx的路径，把include和lib路径配置进去\n\t- 默认include地址：C:\\Program Files (x86)\\Microsoft DirectX SDK (June 2010)\\Include\n\t- 默认library地址：C:\\Program Files (x86)\\Microsoft DirectX SDK (June 2010)\\Lib\\x86 \t\n\t![](/images/Directx11_01_06.png)\n1. Linker->System改成Windows\n\t- 如果报错为**X3501** 'main':entrypoint not found说明这里漏了没改\n\t![](/images/Directx11_01_07.png)\n1. Shader Type改成Effect(/fx)\n\t- 教程里用的是SM4.0，所以相应的把SM改成4.0\n\t![](/images/Directx11_01_08.png)\n1. 本次不用修改，但是跟着教程走下来很容易遇到的一个坑\n\t- 如果字符串用的是L\"xxx\"，选择Unicode Character Set\n\t- 如果字符串前面不带L，选择Multi-Byte Character Set\n\t![](/images/Directx11_01_09.png)\n\n## 成功运行：\n![](/images/Directx11_01_10.png)","source":"_posts/Directx11-01.md","raw":"---\ntitle: Directx11 - 01.配置环境\ndate: 2018-07-29 21:51:03\ntags: Directx11\ncategories: Directx11\nthumbnail: /images/Directx11_01_10.png\n---\n## 选择教程：\n我跟的是[Braynzar Soft Tutorials](https://www.braynzarsoft.net/viewtutorial/q16390-braynzar-soft-directx-11-tutorials)\n之前有跟过[DirectXTutorial.com](http://www.directxtutorial.com/LessonList.aspx?listid=11)，讲的挺好的，但是到一半就要付费了。\n也看到过很多推荐说龙书或者dx自带的教程，但是因为我对C++不是很熟，首要的要求是教程的代码可以直接跑起来的，所以最后选了这个。\n\n## 安装软件：\n- Visual Studio 2017 [Download here](https://visualstudio.microsoft.com/zh-hans/downloads/)\n- DirectX SDK June 2010 [Download here](https://www.microsoft.com/en-us/download/details.aspx?id=6812)\n如果安装dx的时候遇到**s1023**的问题，是因为电脑上已经安装了Microsoft Visual C++ 2010 Redistributable，需要先卸载才能成功安装dx\n![](/images/Directx11_01_01.png)\n![](/images/Directx11_01_02.png)\n\n## 新建项目：\n菜单栏File -> New -> Project\n![](/images/Directx11_01_03.png)\n勾选Empty Project\n![](/images/Directx11_01_04.png)\n在Project的名字（Demo）上右键add->new item，新建main.cpp和Effects.fx两个文件\n![](/images/Directx11_01_05.png)\n详细代码从教程最下面的[Heres the full code](https://www.braynzarsoft.net/viewtutorial/q16390-5-color)复制\n\n## 配置项目：\n在Project的名字（Demo）上右键Properties进行配置\n1. 找到自己安装dx的路径，把include和lib路径配置进去\n\t- 默认include地址：C:\\Program Files (x86)\\Microsoft DirectX SDK (June 2010)\\Include\n\t- 默认library地址：C:\\Program Files (x86)\\Microsoft DirectX SDK (June 2010)\\Lib\\x86 \t\n\t![](/images/Directx11_01_06.png)\n1. Linker->System改成Windows\n\t- 如果报错为**X3501** 'main':entrypoint not found说明这里漏了没改\n\t![](/images/Directx11_01_07.png)\n1. Shader Type改成Effect(/fx)\n\t- 教程里用的是SM4.0，所以相应的把SM改成4.0\n\t![](/images/Directx11_01_08.png)\n1. 本次不用修改，但是跟着教程走下来很容易遇到的一个坑\n\t- 如果字符串用的是L\"xxx\"，选择Unicode Character Set\n\t- 如果字符串前面不带L，选择Multi-Byte Character Set\n\t![](/images/Directx11_01_09.png)\n\n## 成功运行：\n![](/images/Directx11_01_10.png)","slug":"Directx11-01","published":1,"updated":"2020-05-13T04:04:41.661Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka4xpxhx00008st1tss2b1v4","content":"<h2 id=\"选择教程：\"><a href=\"#选择教程：\" class=\"headerlink\" title=\"选择教程：\"></a>选择教程：</h2><p>我跟的是<a href=\"https://www.braynzarsoft.net/viewtutorial/q16390-braynzar-soft-directx-11-tutorials\" target=\"_blank\" rel=\"noopener\">Braynzar Soft Tutorials</a><br>之前有跟过<a href=\"http://www.directxtutorial.com/LessonList.aspx?listid=11\" target=\"_blank\" rel=\"noopener\">DirectXTutorial.com</a>，讲的挺好的，但是到一半就要付费了。<br>也看到过很多推荐说龙书或者dx自带的教程，但是因为我对C++不是很熟，首要的要求是教程的代码可以直接跑起来的，所以最后选了这个。</p>\n<h2 id=\"安装软件：\"><a href=\"#安装软件：\" class=\"headerlink\" title=\"安装软件：\"></a>安装软件：</h2><ul>\n<li>Visual Studio 2017 <a href=\"https://visualstudio.microsoft.com/zh-hans/downloads/\" target=\"_blank\" rel=\"noopener\">Download here</a></li>\n<li>DirectX SDK June 2010 <a href=\"https://www.microsoft.com/en-us/download/details.aspx?id=6812\" target=\"_blank\" rel=\"noopener\">Download here</a><br>如果安装dx的时候遇到<strong>s1023</strong>的问题，是因为电脑上已经安装了Microsoft Visual C++ 2010 Redistributable，需要先卸载才能成功安装dx<br><img src=\"/images/Directx11_01_01.png\" alt><br><img src=\"/images/Directx11_01_02.png\" alt></li>\n</ul>\n<h2 id=\"新建项目：\"><a href=\"#新建项目：\" class=\"headerlink\" title=\"新建项目：\"></a>新建项目：</h2><p>菜单栏File -&gt; New -&gt; Project<br><img src=\"/images/Directx11_01_03.png\" alt><br>勾选Empty Project<br><img src=\"/images/Directx11_01_04.png\" alt><br>在Project的名字（Demo）上右键add-&gt;new item，新建main.cpp和Effects.fx两个文件<br><img src=\"/images/Directx11_01_05.png\" alt><br>详细代码从教程最下面的<a href=\"https://www.braynzarsoft.net/viewtutorial/q16390-5-color\" target=\"_blank\" rel=\"noopener\">Heres the full code</a>复制</p>\n<h2 id=\"配置项目：\"><a href=\"#配置项目：\" class=\"headerlink\" title=\"配置项目：\"></a>配置项目：</h2><p>在Project的名字（Demo）上右键Properties进行配置</p>\n<ol>\n<li>找到自己安装dx的路径，把include和lib路径配置进去<ul>\n<li>默认include地址：C:\\Program Files (x86)\\Microsoft DirectX SDK (June 2010)\\Include</li>\n<li>默认library地址：C:\\Program Files (x86)\\Microsoft DirectX SDK (June 2010)\\Lib\\x86<br><img src=\"/images/Directx11_01_06.png\" alt></li>\n</ul>\n</li>\n<li>Linker-&gt;System改成Windows<ul>\n<li>如果报错为<strong>X3501</strong> ‘main’:entrypoint not found说明这里漏了没改<br><img src=\"/images/Directx11_01_07.png\" alt></li>\n</ul>\n</li>\n<li>Shader Type改成Effect(/fx)<ul>\n<li>教程里用的是SM4.0，所以相应的把SM改成4.0<br><img src=\"/images/Directx11_01_08.png\" alt></li>\n</ul>\n</li>\n<li>本次不用修改，但是跟着教程走下来很容易遇到的一个坑<ul>\n<li>如果字符串用的是L”xxx”，选择Unicode Character Set</li>\n<li>如果字符串前面不带L，选择Multi-Byte Character Set<br><img src=\"/images/Directx11_01_09.png\" alt></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"成功运行：\"><a href=\"#成功运行：\" class=\"headerlink\" title=\"成功运行：\"></a>成功运行：</h2><p><img src=\"/images/Directx11_01_10.png\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"选择教程：\"><a href=\"#选择教程：\" class=\"headerlink\" title=\"选择教程：\"></a>选择教程：</h2><p>我跟的是<a href=\"https://www.braynzarsoft.net/viewtutorial/q16390-braynzar-soft-directx-11-tutorials\" target=\"_blank\" rel=\"noopener\">Braynzar Soft Tutorials</a><br>之前有跟过<a href=\"http://www.directxtutorial.com/LessonList.aspx?listid=11\" target=\"_blank\" rel=\"noopener\">DirectXTutorial.com</a>，讲的挺好的，但是到一半就要付费了。<br>也看到过很多推荐说龙书或者dx自带的教程，但是因为我对C++不是很熟，首要的要求是教程的代码可以直接跑起来的，所以最后选了这个。</p>\n<h2 id=\"安装软件：\"><a href=\"#安装软件：\" class=\"headerlink\" title=\"安装软件：\"></a>安装软件：</h2><ul>\n<li>Visual Studio 2017 <a href=\"https://visualstudio.microsoft.com/zh-hans/downloads/\" target=\"_blank\" rel=\"noopener\">Download here</a></li>\n<li>DirectX SDK June 2010 <a href=\"https://www.microsoft.com/en-us/download/details.aspx?id=6812\" target=\"_blank\" rel=\"noopener\">Download here</a><br>如果安装dx的时候遇到<strong>s1023</strong>的问题，是因为电脑上已经安装了Microsoft Visual C++ 2010 Redistributable，需要先卸载才能成功安装dx<br><img src=\"/images/Directx11_01_01.png\" alt><br><img src=\"/images/Directx11_01_02.png\" alt></li>\n</ul>\n<h2 id=\"新建项目：\"><a href=\"#新建项目：\" class=\"headerlink\" title=\"新建项目：\"></a>新建项目：</h2><p>菜单栏File -&gt; New -&gt; Project<br><img src=\"/images/Directx11_01_03.png\" alt><br>勾选Empty Project<br><img src=\"/images/Directx11_01_04.png\" alt><br>在Project的名字（Demo）上右键add-&gt;new item，新建main.cpp和Effects.fx两个文件<br><img src=\"/images/Directx11_01_05.png\" alt><br>详细代码从教程最下面的<a href=\"https://www.braynzarsoft.net/viewtutorial/q16390-5-color\" target=\"_blank\" rel=\"noopener\">Heres the full code</a>复制</p>\n<h2 id=\"配置项目：\"><a href=\"#配置项目：\" class=\"headerlink\" title=\"配置项目：\"></a>配置项目：</h2><p>在Project的名字（Demo）上右键Properties进行配置</p>\n<ol>\n<li>找到自己安装dx的路径，把include和lib路径配置进去<ul>\n<li>默认include地址：C:\\Program Files (x86)\\Microsoft DirectX SDK (June 2010)\\Include</li>\n<li>默认library地址：C:\\Program Files (x86)\\Microsoft DirectX SDK (June 2010)\\Lib\\x86<br><img src=\"/images/Directx11_01_06.png\" alt></li>\n</ul>\n</li>\n<li>Linker-&gt;System改成Windows<ul>\n<li>如果报错为<strong>X3501</strong> ‘main’:entrypoint not found说明这里漏了没改<br><img src=\"/images/Directx11_01_07.png\" alt></li>\n</ul>\n</li>\n<li>Shader Type改成Effect(/fx)<ul>\n<li>教程里用的是SM4.0，所以相应的把SM改成4.0<br><img src=\"/images/Directx11_01_08.png\" alt></li>\n</ul>\n</li>\n<li>本次不用修改，但是跟着教程走下来很容易遇到的一个坑<ul>\n<li>如果字符串用的是L”xxx”，选择Unicode Character Set</li>\n<li>如果字符串前面不带L，选择Multi-Byte Character Set<br><img src=\"/images/Directx11_01_09.png\" alt></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"成功运行：\"><a href=\"#成功运行：\" class=\"headerlink\" title=\"成功运行：\"></a>成功运行：</h2><p><img src=\"/images/Directx11_01_10.png\" alt></p>\n"},{"title":"Directx11 - 02.流程梳理","date":"2018-09-03T09:19:31.000Z","thumbnail":"/images/Directx11_02_01.png","_content":"\n```\nWinMain()\n  InitWindow()       //创建Windows窗口\n  InitD3D11()        //创建Directx的设备接口\n  InitScene()        //调用设备接口，创建渲染pipeline要用到的各种接口\n    InitIAStage()    //因为IAStage在渲染中不变，所以创建完后直接set了\n  MessageLoop()      //循环函数\n    UpdateScene()    //把矩阵，光照的update放在这里，纯数学计算\n    DrawScene()      //填充数据，set pipeline要用到的接口，Draw（）\n  CleanUp()          //循环结束后释放内存\n```\n\n## InitD3D11() \n- 通过D3D11CreateDeviceAndSwapChain()创建swapChain，d3d11Device和d3d11DevCon。\n- 创建renderTargetView和depthStencilView，执行OMSetRenderTargets()\n![](/images/Directx11_02_01.png)\n\n## InitScene() \n- 创建渲染pipeline要用到的各种接口\n- 创建顺序并不是依照渲染顺序，先搭好框架，后面再实际填入数据\n- 不需要更新的可以在这里填入数据并set\n![](/images/Directx11_02_02.png)\n\n##  DrawScene()\n- 这个函数会依照实际渲染需求而改动，但整体流程都是clear->update->set->draw\n![](/images/Directx11_02_03.png)\n\n## 总图\n![](/images/Directx11_02_04.png)","source":"_posts/Directx11-02.md","raw":"---\ntitle: Directx11 - 02.流程梳理\ndate: 2018-09-03 17:19:31\ntags: Directx11\ncategories: Directx11\nthumbnail: /images/Directx11_02_01.png\n---\n\n```\nWinMain()\n  InitWindow()       //创建Windows窗口\n  InitD3D11()        //创建Directx的设备接口\n  InitScene()        //调用设备接口，创建渲染pipeline要用到的各种接口\n    InitIAStage()    //因为IAStage在渲染中不变，所以创建完后直接set了\n  MessageLoop()      //循环函数\n    UpdateScene()    //把矩阵，光照的update放在这里，纯数学计算\n    DrawScene()      //填充数据，set pipeline要用到的接口，Draw（）\n  CleanUp()          //循环结束后释放内存\n```\n\n## InitD3D11() \n- 通过D3D11CreateDeviceAndSwapChain()创建swapChain，d3d11Device和d3d11DevCon。\n- 创建renderTargetView和depthStencilView，执行OMSetRenderTargets()\n![](/images/Directx11_02_01.png)\n\n## InitScene() \n- 创建渲染pipeline要用到的各种接口\n- 创建顺序并不是依照渲染顺序，先搭好框架，后面再实际填入数据\n- 不需要更新的可以在这里填入数据并set\n![](/images/Directx11_02_02.png)\n\n##  DrawScene()\n- 这个函数会依照实际渲染需求而改动，但整体流程都是clear->update->set->draw\n![](/images/Directx11_02_03.png)\n\n## 总图\n![](/images/Directx11_02_04.png)","slug":"Directx11-02","published":1,"updated":"2020-05-13T04:04:41.661Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka4xpxi500028st1bjzi9f0f","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WinMain()</span><br><span class=\"line\">  InitWindow()       //创建Windows窗口</span><br><span class=\"line\">  InitD3D11()        //创建Directx的设备接口</span><br><span class=\"line\">  InitScene()        //调用设备接口，创建渲染pipeline要用到的各种接口</span><br><span class=\"line\">    InitIAStage()    //因为IAStage在渲染中不变，所以创建完后直接set了</span><br><span class=\"line\">  MessageLoop()      //循环函数</span><br><span class=\"line\">    UpdateScene()    //把矩阵，光照的update放在这里，纯数学计算</span><br><span class=\"line\">    DrawScene()      //填充数据，set pipeline要用到的接口，Draw（）</span><br><span class=\"line\">  CleanUp()          //循环结束后释放内存</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"InitD3D11\"><a href=\"#InitD3D11\" class=\"headerlink\" title=\"InitD3D11()\"></a>InitD3D11()</h2><ul>\n<li>通过D3D11CreateDeviceAndSwapChain()创建swapChain，d3d11Device和d3d11DevCon。</li>\n<li>创建renderTargetView和depthStencilView，执行OMSetRenderTargets()<br><img src=\"/images/Directx11_02_01.png\" alt></li>\n</ul>\n<h2 id=\"InitScene\"><a href=\"#InitScene\" class=\"headerlink\" title=\"InitScene()\"></a>InitScene()</h2><ul>\n<li>创建渲染pipeline要用到的各种接口</li>\n<li>创建顺序并不是依照渲染顺序，先搭好框架，后面再实际填入数据</li>\n<li>不需要更新的可以在这里填入数据并set<br><img src=\"/images/Directx11_02_02.png\" alt></li>\n</ul>\n<h2 id=\"DrawScene\"><a href=\"#DrawScene\" class=\"headerlink\" title=\"DrawScene()\"></a>DrawScene()</h2><ul>\n<li>这个函数会依照实际渲染需求而改动，但整体流程都是clear-&gt;update-&gt;set-&gt;draw<br><img src=\"/images/Directx11_02_03.png\" alt></li>\n</ul>\n<h2 id=\"总图\"><a href=\"#总图\" class=\"headerlink\" title=\"总图\"></a>总图</h2><p><img src=\"/images/Directx11_02_04.png\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WinMain()</span><br><span class=\"line\">  InitWindow()       //创建Windows窗口</span><br><span class=\"line\">  InitD3D11()        //创建Directx的设备接口</span><br><span class=\"line\">  InitScene()        //调用设备接口，创建渲染pipeline要用到的各种接口</span><br><span class=\"line\">    InitIAStage()    //因为IAStage在渲染中不变，所以创建完后直接set了</span><br><span class=\"line\">  MessageLoop()      //循环函数</span><br><span class=\"line\">    UpdateScene()    //把矩阵，光照的update放在这里，纯数学计算</span><br><span class=\"line\">    DrawScene()      //填充数据，set pipeline要用到的接口，Draw（）</span><br><span class=\"line\">  CleanUp()          //循环结束后释放内存</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"InitD3D11\"><a href=\"#InitD3D11\" class=\"headerlink\" title=\"InitD3D11()\"></a>InitD3D11()</h2><ul>\n<li>通过D3D11CreateDeviceAndSwapChain()创建swapChain，d3d11Device和d3d11DevCon。</li>\n<li>创建renderTargetView和depthStencilView，执行OMSetRenderTargets()<br><img src=\"/images/Directx11_02_01.png\" alt></li>\n</ul>\n<h2 id=\"InitScene\"><a href=\"#InitScene\" class=\"headerlink\" title=\"InitScene()\"></a>InitScene()</h2><ul>\n<li>创建渲染pipeline要用到的各种接口</li>\n<li>创建顺序并不是依照渲染顺序，先搭好框架，后面再实际填入数据</li>\n<li>不需要更新的可以在这里填入数据并set<br><img src=\"/images/Directx11_02_02.png\" alt></li>\n</ul>\n<h2 id=\"DrawScene\"><a href=\"#DrawScene\" class=\"headerlink\" title=\"DrawScene()\"></a>DrawScene()</h2><ul>\n<li>这个函数会依照实际渲染需求而改动，但整体流程都是clear-&gt;update-&gt;set-&gt;draw<br><img src=\"/images/Directx11_02_03.png\" alt></li>\n</ul>\n<h2 id=\"总图\"><a href=\"#总图\" class=\"headerlink\" title=\"总图\"></a>总图</h2><p><img src=\"/images/Directx11_02_04.png\" alt></p>\n"},{"title":"RTR - 02. The Graphics Rendering Pipeline","date":"2018-10-22T12:16:27.000Z","thumbnail":"/images/RTR4.02.02.png","_content":"## The Graphics Rendering Pipeline\n![](/images/RTR4.02.02.png)\n\n### 1. Application\n- software\n- CPU\n- collision detection / global acceleration / animation / physical simulation / ...\n- not divide into substages -> executed in paraller -> superscalar construction\n\n=>**geometry / rendering primitives**\n\n---\n\n### 2. Geometry Peocessing\n-  what / how / where\n- GPU\n![](/images/RTR4.02.03.png)\n\n#### 2.1 Vertex Shading\n- compute the position for a vertex\n   - **model -> world -> view / eye / camera**\n- evaluate vertex output data\n   - Vertex shading: compute a shading equation\n\n#### 2.2 Projection\n- orthographic / parallel\n- perspective\n- view volume to unit cube -> **project**\n- z coordinate -> stored in z-buffer, the models are projected from 3 to 2 dimensions\n\n#### 2.3 Clipping\n- clip with unit cube -> **clip**\n\n#### 2.4 Screen Mapping\n- 1x1 -> 1920x1080 -> **screen/window**\n\n=>**transformed and projected vertices with their shading data**\n\n---\n\n### 3. Rasterization\n![](/images/RTR4.02.08.png)\n- triangle setup / primitive assembly\n- triangle traversal\n   - find which samples or pixels are inside a triangle\n\n\n- fixed function\n- hardware\n- triangles are formed from three vertices\n\n=>**fragment**\n\n---\n\n### 4. Pixel Peocessing\n- pixel shading\n   - programmable GPU core\n   - texturing\n- merging\n   - highly configurable\n   - combine the fragment color with color buffer\n   - visibility\n   - alpha channel / stencil buffer / frame buffer /...\n\n---\n- double buffering\n- different coordinates\n![](/images/RTR4_02_01.png)","source":"_posts/RTR-02.md","raw":"---\ntitle: RTR - 02. The Graphics Rendering Pipeline\ndate: 2018-10-22 20:16:27\ntags: Real Time Rendering\ncategories: Real Time Rendering\nthumbnail: /images/RTR4.02.02.png\n---\n## The Graphics Rendering Pipeline\n![](/images/RTR4.02.02.png)\n\n### 1. Application\n- software\n- CPU\n- collision detection / global acceleration / animation / physical simulation / ...\n- not divide into substages -> executed in paraller -> superscalar construction\n\n=>**geometry / rendering primitives**\n\n---\n\n### 2. Geometry Peocessing\n-  what / how / where\n- GPU\n![](/images/RTR4.02.03.png)\n\n#### 2.1 Vertex Shading\n- compute the position for a vertex\n   - **model -> world -> view / eye / camera**\n- evaluate vertex output data\n   - Vertex shading: compute a shading equation\n\n#### 2.2 Projection\n- orthographic / parallel\n- perspective\n- view volume to unit cube -> **project**\n- z coordinate -> stored in z-buffer, the models are projected from 3 to 2 dimensions\n\n#### 2.3 Clipping\n- clip with unit cube -> **clip**\n\n#### 2.4 Screen Mapping\n- 1x1 -> 1920x1080 -> **screen/window**\n\n=>**transformed and projected vertices with their shading data**\n\n---\n\n### 3. Rasterization\n![](/images/RTR4.02.08.png)\n- triangle setup / primitive assembly\n- triangle traversal\n   - find which samples or pixels are inside a triangle\n\n\n- fixed function\n- hardware\n- triangles are formed from three vertices\n\n=>**fragment**\n\n---\n\n### 4. Pixel Peocessing\n- pixel shading\n   - programmable GPU core\n   - texturing\n- merging\n   - highly configurable\n   - combine the fragment color with color buffer\n   - visibility\n   - alpha channel / stencil buffer / frame buffer /...\n\n---\n- double buffering\n- different coordinates\n![](/images/RTR4_02_01.png)","slug":"RTR-02","published":1,"updated":"2020-05-13T04:04:41.662Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka4xpxia00058st144z64i43","content":"<h2 id=\"The-Graphics-Rendering-Pipeline\"><a href=\"#The-Graphics-Rendering-Pipeline\" class=\"headerlink\" title=\"The Graphics Rendering Pipeline\"></a>The Graphics Rendering Pipeline</h2><p><img src=\"/images/RTR4.02.02.png\" alt></p>\n<h3 id=\"1-Application\"><a href=\"#1-Application\" class=\"headerlink\" title=\"1. Application\"></a>1. Application</h3><ul>\n<li>software</li>\n<li>CPU</li>\n<li>collision detection / global acceleration / animation / physical simulation / …</li>\n<li>not divide into substages -&gt; executed in paraller -&gt; superscalar construction</li>\n</ul>\n<p>=&gt;<strong>geometry / rendering primitives</strong></p>\n<hr>\n<h3 id=\"2-Geometry-Peocessing\"><a href=\"#2-Geometry-Peocessing\" class=\"headerlink\" title=\"2. Geometry Peocessing\"></a>2. Geometry Peocessing</h3><ul>\n<li>what / how / where</li>\n<li>GPU<br><img src=\"/images/RTR4.02.03.png\" alt></li>\n</ul>\n<h4 id=\"2-1-Vertex-Shading\"><a href=\"#2-1-Vertex-Shading\" class=\"headerlink\" title=\"2.1 Vertex Shading\"></a>2.1 Vertex Shading</h4><ul>\n<li>compute the position for a vertex<ul>\n<li><strong>model -&gt; world -&gt; view / eye / camera</strong></li>\n</ul>\n</li>\n<li>evaluate vertex output data<ul>\n<li>Vertex shading: compute a shading equation</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-2-Projection\"><a href=\"#2-2-Projection\" class=\"headerlink\" title=\"2.2 Projection\"></a>2.2 Projection</h4><ul>\n<li>orthographic / parallel</li>\n<li>perspective</li>\n<li>view volume to unit cube -&gt; <strong>project</strong></li>\n<li>z coordinate -&gt; stored in z-buffer, the models are projected from 3 to 2 dimensions</li>\n</ul>\n<h4 id=\"2-3-Clipping\"><a href=\"#2-3-Clipping\" class=\"headerlink\" title=\"2.3 Clipping\"></a>2.3 Clipping</h4><ul>\n<li>clip with unit cube -&gt; <strong>clip</strong></li>\n</ul>\n<h4 id=\"2-4-Screen-Mapping\"><a href=\"#2-4-Screen-Mapping\" class=\"headerlink\" title=\"2.4 Screen Mapping\"></a>2.4 Screen Mapping</h4><ul>\n<li>1x1 -&gt; 1920x1080 -&gt; <strong>screen/window</strong></li>\n</ul>\n<p>=&gt;<strong>transformed and projected vertices with their shading data</strong></p>\n<hr>\n<h3 id=\"3-Rasterization\"><a href=\"#3-Rasterization\" class=\"headerlink\" title=\"3. Rasterization\"></a>3. Rasterization</h3><p><img src=\"/images/RTR4.02.08.png\" alt></p>\n<ul>\n<li>triangle setup / primitive assembly</li>\n<li>triangle traversal<ul>\n<li>find which samples or pixels are inside a triangle</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>fixed function</li>\n<li>hardware</li>\n<li>triangles are formed from three vertices</li>\n</ul>\n<p>=&gt;<strong>fragment</strong></p>\n<hr>\n<h3 id=\"4-Pixel-Peocessing\"><a href=\"#4-Pixel-Peocessing\" class=\"headerlink\" title=\"4. Pixel Peocessing\"></a>4. Pixel Peocessing</h3><ul>\n<li>pixel shading<ul>\n<li>programmable GPU core</li>\n<li>texturing</li>\n</ul>\n</li>\n<li>merging<ul>\n<li>highly configurable</li>\n<li>combine the fragment color with color buffer</li>\n<li>visibility</li>\n<li>alpha channel / stencil buffer / frame buffer /…</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ul>\n<li>double buffering</li>\n<li>different coordinates<br><img src=\"/images/RTR4_02_01.png\" alt></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"The-Graphics-Rendering-Pipeline\"><a href=\"#The-Graphics-Rendering-Pipeline\" class=\"headerlink\" title=\"The Graphics Rendering Pipeline\"></a>The Graphics Rendering Pipeline</h2><p><img src=\"/images/RTR4.02.02.png\" alt></p>\n<h3 id=\"1-Application\"><a href=\"#1-Application\" class=\"headerlink\" title=\"1. Application\"></a>1. Application</h3><ul>\n<li>software</li>\n<li>CPU</li>\n<li>collision detection / global acceleration / animation / physical simulation / …</li>\n<li>not divide into substages -&gt; executed in paraller -&gt; superscalar construction</li>\n</ul>\n<p>=&gt;<strong>geometry / rendering primitives</strong></p>\n<hr>\n<h3 id=\"2-Geometry-Peocessing\"><a href=\"#2-Geometry-Peocessing\" class=\"headerlink\" title=\"2. Geometry Peocessing\"></a>2. Geometry Peocessing</h3><ul>\n<li>what / how / where</li>\n<li>GPU<br><img src=\"/images/RTR4.02.03.png\" alt></li>\n</ul>\n<h4 id=\"2-1-Vertex-Shading\"><a href=\"#2-1-Vertex-Shading\" class=\"headerlink\" title=\"2.1 Vertex Shading\"></a>2.1 Vertex Shading</h4><ul>\n<li>compute the position for a vertex<ul>\n<li><strong>model -&gt; world -&gt; view / eye / camera</strong></li>\n</ul>\n</li>\n<li>evaluate vertex output data<ul>\n<li>Vertex shading: compute a shading equation</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-2-Projection\"><a href=\"#2-2-Projection\" class=\"headerlink\" title=\"2.2 Projection\"></a>2.2 Projection</h4><ul>\n<li>orthographic / parallel</li>\n<li>perspective</li>\n<li>view volume to unit cube -&gt; <strong>project</strong></li>\n<li>z coordinate -&gt; stored in z-buffer, the models are projected from 3 to 2 dimensions</li>\n</ul>\n<h4 id=\"2-3-Clipping\"><a href=\"#2-3-Clipping\" class=\"headerlink\" title=\"2.3 Clipping\"></a>2.3 Clipping</h4><ul>\n<li>clip with unit cube -&gt; <strong>clip</strong></li>\n</ul>\n<h4 id=\"2-4-Screen-Mapping\"><a href=\"#2-4-Screen-Mapping\" class=\"headerlink\" title=\"2.4 Screen Mapping\"></a>2.4 Screen Mapping</h4><ul>\n<li>1x1 -&gt; 1920x1080 -&gt; <strong>screen/window</strong></li>\n</ul>\n<p>=&gt;<strong>transformed and projected vertices with their shading data</strong></p>\n<hr>\n<h3 id=\"3-Rasterization\"><a href=\"#3-Rasterization\" class=\"headerlink\" title=\"3. Rasterization\"></a>3. Rasterization</h3><p><img src=\"/images/RTR4.02.08.png\" alt></p>\n<ul>\n<li>triangle setup / primitive assembly</li>\n<li>triangle traversal<ul>\n<li>find which samples or pixels are inside a triangle</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>fixed function</li>\n<li>hardware</li>\n<li>triangles are formed from three vertices</li>\n</ul>\n<p>=&gt;<strong>fragment</strong></p>\n<hr>\n<h3 id=\"4-Pixel-Peocessing\"><a href=\"#4-Pixel-Peocessing\" class=\"headerlink\" title=\"4. Pixel Peocessing\"></a>4. Pixel Peocessing</h3><ul>\n<li>pixel shading<ul>\n<li>programmable GPU core</li>\n<li>texturing</li>\n</ul>\n</li>\n<li>merging<ul>\n<li>highly configurable</li>\n<li>combine the fragment color with color buffer</li>\n<li>visibility</li>\n<li>alpha channel / stencil buffer / frame buffer /…</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ul>\n<li>double buffering</li>\n<li>different coordinates<br><img src=\"/images/RTR4_02_01.png\" alt></li>\n</ul>\n"},{"title":"RTR - 03. The Graphics Processing Unit","date":"2018-11-12T14:39:03.000Z","thumbnail":"/images/RTR4.03.02.png","_content":"## The Graphics Processing Unit\n\n**CPU:**\n- wide variety of data structures\n- large code bases\n- can have multiple processors, but each run code in a mostly serial fashion\n- consist of fast local caches\n- using clever techniques to avoid stalls\n\n**GPU:**\n- less chip area dedicated to cache memory and control logic\n- lantency is higher\n- large set of processors(shader core), often numbering in the thousands\n- process data in parallel fashion\n\n---\n\n**thread:**\neach pixel shader invocation for a fragment ( not equal to CPU thread )\n\n**warp:**\nthreads use the same shader program are bundled into groups, called **warps** by NVIDIA, **wavefronts** by AMD\n\n2000 threads, warps on NVIDIA GPU contain 32 threads => 2000/32=62.5=>63 threads\n\nmore registers needed with each thread↑ -> threads↓ warps can be resident in the GPU↓\n\nwarps that are resident are said to be **in flight** and this number is called the  **occupancy**\n\n**influence efficiency:**\n- shader program's structure: =>occupancy\n- dynamic branching: =>if\n\n---\n![](/images/RTR4.03.02.png)\nThis is the **logical model** of the GPU. The real implement on hardware: **physical model**\n\n- unified shader design => vertex/pixel/gemotry/tessellation/... share a common programming model\nhave the same **instructuin set architexture ( ISA )**\n- A processor that implements this model is called **common-shader core** in DirextX.\n- A GPU with such cores is saied to have a **unified shader architecture**\n\n---\n\nHLSL can compiled to virtual machine bytecode, **intermediate language ( IL or DXIL )**\n\n**draw call** : invoke the graphics API to draw a group of primitives\n\n---\n\n- uniform input: keep constant throughout a draw call => constant register\n- verying input: varies for each vertex or pixel =>temporary register\n![](/images/RTR4.03.03.png)\n\n---\n\n**flow control:**\n- static: \nbased on the values of uniform inputs, the flow of the code is constant over the draw call\n- dynamic:\nbased on the values of varying inputs, each fragment can execute the code differently\n\n---\n\n- AMD&DICE: Mantle API->Vulkan (API), SPIRV (intermediate language), works from workstations to mobile devices\n- Apple: Metal\n- OPENGL ES ( embedded system) -> WebGL\n\n---\n\nDirectX: input assembler -> vertex shader\n => an example where the physical model often differs from the logical\n\n---\n\n**Tessellation Stage:**\n- hull shader\n- tessellator\n- domain shader\n\n- curved surface\n- LOD\n\n**Geometry Shader:**\nadd / delete / modify /... primitives\n\n---\n\n**MRT:**\nmultiple render targets => deferred shading\n\n---\n\n- DX11: **UAV**, unordered access view, allow write access to any location\n- OpenGL: **SSBO**, shader storage buffer object\n**ROV:** rasterizer order views, like UAV, but guarantee data are accessed in order\n\n---\n\n**early-z:** \nmerge testing -> pixel shader\nbut if change of discard z-depth in pixel shader, early-z can't be used\n\n**computer shader:**\n- post-processing\n- particle system\ncan access data generated on the GPU","source":"_posts/RTR-03.md","raw":"---\ntitle: RTR - 03. The Graphics Processing Unit\ndate: 2018-11-12 22:39:03\ntags: Real Time Rendering\ncategories: Real Time Rendering\nthumbnail: /images/RTR4.03.02.png\n---\n## The Graphics Processing Unit\n\n**CPU:**\n- wide variety of data structures\n- large code bases\n- can have multiple processors, but each run code in a mostly serial fashion\n- consist of fast local caches\n- using clever techniques to avoid stalls\n\n**GPU:**\n- less chip area dedicated to cache memory and control logic\n- lantency is higher\n- large set of processors(shader core), often numbering in the thousands\n- process data in parallel fashion\n\n---\n\n**thread:**\neach pixel shader invocation for a fragment ( not equal to CPU thread )\n\n**warp:**\nthreads use the same shader program are bundled into groups, called **warps** by NVIDIA, **wavefronts** by AMD\n\n2000 threads, warps on NVIDIA GPU contain 32 threads => 2000/32=62.5=>63 threads\n\nmore registers needed with each thread↑ -> threads↓ warps can be resident in the GPU↓\n\nwarps that are resident are said to be **in flight** and this number is called the  **occupancy**\n\n**influence efficiency:**\n- shader program's structure: =>occupancy\n- dynamic branching: =>if\n\n---\n![](/images/RTR4.03.02.png)\nThis is the **logical model** of the GPU. The real implement on hardware: **physical model**\n\n- unified shader design => vertex/pixel/gemotry/tessellation/... share a common programming model\nhave the same **instructuin set architexture ( ISA )**\n- A processor that implements this model is called **common-shader core** in DirextX.\n- A GPU with such cores is saied to have a **unified shader architecture**\n\n---\n\nHLSL can compiled to virtual machine bytecode, **intermediate language ( IL or DXIL )**\n\n**draw call** : invoke the graphics API to draw a group of primitives\n\n---\n\n- uniform input: keep constant throughout a draw call => constant register\n- verying input: varies for each vertex or pixel =>temporary register\n![](/images/RTR4.03.03.png)\n\n---\n\n**flow control:**\n- static: \nbased on the values of uniform inputs, the flow of the code is constant over the draw call\n- dynamic:\nbased on the values of varying inputs, each fragment can execute the code differently\n\n---\n\n- AMD&DICE: Mantle API->Vulkan (API), SPIRV (intermediate language), works from workstations to mobile devices\n- Apple: Metal\n- OPENGL ES ( embedded system) -> WebGL\n\n---\n\nDirectX: input assembler -> vertex shader\n => an example where the physical model often differs from the logical\n\n---\n\n**Tessellation Stage:**\n- hull shader\n- tessellator\n- domain shader\n\n- curved surface\n- LOD\n\n**Geometry Shader:**\nadd / delete / modify /... primitives\n\n---\n\n**MRT:**\nmultiple render targets => deferred shading\n\n---\n\n- DX11: **UAV**, unordered access view, allow write access to any location\n- OpenGL: **SSBO**, shader storage buffer object\n**ROV:** rasterizer order views, like UAV, but guarantee data are accessed in order\n\n---\n\n**early-z:** \nmerge testing -> pixel shader\nbut if change of discard z-depth in pixel shader, early-z can't be used\n\n**computer shader:**\n- post-processing\n- particle system\ncan access data generated on the GPU","slug":"RTR-03","published":1,"updated":"2020-05-13T04:04:41.663Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka4xpxid00068st1dtxiwwyi","content":"<h2 id=\"The-Graphics-Processing-Unit\"><a href=\"#The-Graphics-Processing-Unit\" class=\"headerlink\" title=\"The Graphics Processing Unit\"></a>The Graphics Processing Unit</h2><p><strong>CPU:</strong></p>\n<ul>\n<li>wide variety of data structures</li>\n<li>large code bases</li>\n<li>can have multiple processors, but each run code in a mostly serial fashion</li>\n<li>consist of fast local caches</li>\n<li>using clever techniques to avoid stalls</li>\n</ul>\n<p><strong>GPU:</strong></p>\n<ul>\n<li>less chip area dedicated to cache memory and control logic</li>\n<li>lantency is higher</li>\n<li>large set of processors(shader core), often numbering in the thousands</li>\n<li>process data in parallel fashion</li>\n</ul>\n<hr>\n<p><strong>thread:</strong><br>each pixel shader invocation for a fragment ( not equal to CPU thread )</p>\n<p><strong>warp:</strong><br>threads use the same shader program are bundled into groups, called <strong>warps</strong> by NVIDIA, <strong>wavefronts</strong> by AMD</p>\n<p>2000 threads, warps on NVIDIA GPU contain 32 threads =&gt; 2000/32=62.5=&gt;63 threads</p>\n<p>more registers needed with each thread↑ -&gt; threads↓ warps can be resident in the GPU↓</p>\n<p>warps that are resident are said to be <strong>in flight</strong> and this number is called the  <strong>occupancy</strong></p>\n<p><strong>influence efficiency:</strong></p>\n<ul>\n<li>shader program’s structure: =&gt;occupancy</li>\n<li>dynamic branching: =&gt;if</li>\n</ul>\n<hr>\n<p><img src=\"/images/RTR4.03.02.png\" alt><br>This is the <strong>logical model</strong> of the GPU. The real implement on hardware: <strong>physical model</strong></p>\n<ul>\n<li>unified shader design =&gt; vertex/pixel/gemotry/tessellation/… share a common programming model<br>have the same <strong>instructuin set architexture ( ISA )</strong></li>\n<li>A processor that implements this model is called <strong>common-shader core</strong> in DirextX.</li>\n<li>A GPU with such cores is saied to have a <strong>unified shader architecture</strong></li>\n</ul>\n<hr>\n<p>HLSL can compiled to virtual machine bytecode, <strong>intermediate language ( IL or DXIL )</strong></p>\n<p><strong>draw call</strong> : invoke the graphics API to draw a group of primitives</p>\n<hr>\n<ul>\n<li>uniform input: keep constant throughout a draw call =&gt; constant register</li>\n<li>verying input: varies for each vertex or pixel =&gt;temporary register<br><img src=\"/images/RTR4.03.03.png\" alt></li>\n</ul>\n<hr>\n<p><strong>flow control:</strong></p>\n<ul>\n<li>static:<br>based on the values of uniform inputs, the flow of the code is constant over the draw call</li>\n<li>dynamic:<br>based on the values of varying inputs, each fragment can execute the code differently</li>\n</ul>\n<hr>\n<ul>\n<li>AMD&amp;DICE: Mantle API-&gt;Vulkan (API), SPIRV (intermediate language), works from workstations to mobile devices</li>\n<li>Apple: Metal</li>\n<li>OPENGL ES ( embedded system) -&gt; WebGL</li>\n</ul>\n<hr>\n<p>DirectX: input assembler -&gt; vertex shader<br> =&gt; an example where the physical model often differs from the logical</p>\n<hr>\n<p><strong>Tessellation Stage:</strong></p>\n<ul>\n<li><p>hull shader</p>\n</li>\n<li><p>tessellator</p>\n</li>\n<li><p>domain shader</p>\n</li>\n<li><p>curved surface</p>\n</li>\n<li><p>LOD</p>\n</li>\n</ul>\n<p><strong>Geometry Shader:</strong><br>add / delete / modify /… primitives</p>\n<hr>\n<p><strong>MRT:</strong><br>multiple render targets =&gt; deferred shading</p>\n<hr>\n<ul>\n<li>DX11: <strong>UAV</strong>, unordered access view, allow write access to any location</li>\n<li>OpenGL: <strong>SSBO</strong>, shader storage buffer object</li>\n</ul>\n<p><strong>ROV:</strong> rasterizer order views, like UAV, but guarantee data are accessed in order</p>\n<hr>\n<p><strong>early-z:</strong><br>merge testing -&gt; pixel shader<br>but if change of discard z-depth in pixel shader, early-z can’t be used</p>\n<p><strong>computer shader:</strong></p>\n<ul>\n<li>post-processing</li>\n<li>particle system<br>can access data generated on the GPU</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"The-Graphics-Processing-Unit\"><a href=\"#The-Graphics-Processing-Unit\" class=\"headerlink\" title=\"The Graphics Processing Unit\"></a>The Graphics Processing Unit</h2><p><strong>CPU:</strong></p>\n<ul>\n<li>wide variety of data structures</li>\n<li>large code bases</li>\n<li>can have multiple processors, but each run code in a mostly serial fashion</li>\n<li>consist of fast local caches</li>\n<li>using clever techniques to avoid stalls</li>\n</ul>\n<p><strong>GPU:</strong></p>\n<ul>\n<li>less chip area dedicated to cache memory and control logic</li>\n<li>lantency is higher</li>\n<li>large set of processors(shader core), often numbering in the thousands</li>\n<li>process data in parallel fashion</li>\n</ul>\n<hr>\n<p><strong>thread:</strong><br>each pixel shader invocation for a fragment ( not equal to CPU thread )</p>\n<p><strong>warp:</strong><br>threads use the same shader program are bundled into groups, called <strong>warps</strong> by NVIDIA, <strong>wavefronts</strong> by AMD</p>\n<p>2000 threads, warps on NVIDIA GPU contain 32 threads =&gt; 2000/32=62.5=&gt;63 threads</p>\n<p>more registers needed with each thread↑ -&gt; threads↓ warps can be resident in the GPU↓</p>\n<p>warps that are resident are said to be <strong>in flight</strong> and this number is called the  <strong>occupancy</strong></p>\n<p><strong>influence efficiency:</strong></p>\n<ul>\n<li>shader program’s structure: =&gt;occupancy</li>\n<li>dynamic branching: =&gt;if</li>\n</ul>\n<hr>\n<p><img src=\"/images/RTR4.03.02.png\" alt><br>This is the <strong>logical model</strong> of the GPU. The real implement on hardware: <strong>physical model</strong></p>\n<ul>\n<li>unified shader design =&gt; vertex/pixel/gemotry/tessellation/… share a common programming model<br>have the same <strong>instructuin set architexture ( ISA )</strong></li>\n<li>A processor that implements this model is called <strong>common-shader core</strong> in DirextX.</li>\n<li>A GPU with such cores is saied to have a <strong>unified shader architecture</strong></li>\n</ul>\n<hr>\n<p>HLSL can compiled to virtual machine bytecode, <strong>intermediate language ( IL or DXIL )</strong></p>\n<p><strong>draw call</strong> : invoke the graphics API to draw a group of primitives</p>\n<hr>\n<ul>\n<li>uniform input: keep constant throughout a draw call =&gt; constant register</li>\n<li>verying input: varies for each vertex or pixel =&gt;temporary register<br><img src=\"/images/RTR4.03.03.png\" alt></li>\n</ul>\n<hr>\n<p><strong>flow control:</strong></p>\n<ul>\n<li>static:<br>based on the values of uniform inputs, the flow of the code is constant over the draw call</li>\n<li>dynamic:<br>based on the values of varying inputs, each fragment can execute the code differently</li>\n</ul>\n<hr>\n<ul>\n<li>AMD&amp;DICE: Mantle API-&gt;Vulkan (API), SPIRV (intermediate language), works from workstations to mobile devices</li>\n<li>Apple: Metal</li>\n<li>OPENGL ES ( embedded system) -&gt; WebGL</li>\n</ul>\n<hr>\n<p>DirectX: input assembler -&gt; vertex shader<br> =&gt; an example where the physical model often differs from the logical</p>\n<hr>\n<p><strong>Tessellation Stage:</strong></p>\n<ul>\n<li><p>hull shader</p>\n</li>\n<li><p>tessellator</p>\n</li>\n<li><p>domain shader</p>\n</li>\n<li><p>curved surface</p>\n</li>\n<li><p>LOD</p>\n</li>\n</ul>\n<p><strong>Geometry Shader:</strong><br>add / delete / modify /… primitives</p>\n<hr>\n<p><strong>MRT:</strong><br>multiple render targets =&gt; deferred shading</p>\n<hr>\n<ul>\n<li>DX11: <strong>UAV</strong>, unordered access view, allow write access to any location</li>\n<li>OpenGL: <strong>SSBO</strong>, shader storage buffer object</li>\n</ul>\n<p><strong>ROV:</strong> rasterizer order views, like UAV, but guarantee data are accessed in order</p>\n<hr>\n<p><strong>early-z:</strong><br>merge testing -&gt; pixel shader<br>but if change of discard z-depth in pixel shader, early-z can’t be used</p>\n<p><strong>computer shader:</strong></p>\n<ul>\n<li>post-processing</li>\n<li>particle system<br>can access data generated on the GPU</li>\n</ul>\n"},{"title":"Mark Down","date":"2018-07-17T02:30:37.000Z","_content":"\n\tdelete node_modules\n\tnpm install hexo --save\n\n这里是第一段\n这里是第二段\n这个是一级标题\n===\n这个是二级标题\n---\n>这是一个块\n这是一个块\n这是一个块\n这是一个块\n>>这又是一个块\n这又是一个块\n这又是一个块\n这又是一个块\n\n- 无序列表\n- 无序列表\n- 无序列表\n+ 无序列表\n* 无序列表\n\n1. 有序列表\n1. 有序列表\n1. 有序列表\n\n1986\\. 转义点号防止变成列表\n\n    Hello World\n    这里是代码块\n    Bye Bye\n\n***\n---\n___\n\n*斜体*\n**粗体**\n~~删除线~~\n[超链接](http://www.google.cn/)\n\\##这不是二级标题\n\n| Item     | Value     | Qty   |\n| :------- | --------: | :---: |\n| Computer | 1600 USD  | 5     |\n| Phone    | 12 USD    | 12    |\n| Pipe     | 1 USD     | 234   |\n\n这是用```Hello World```表示的行内代码块","source":"_posts/MarkDown.md","raw":"---\ntitle: Mark Down\ndate: 2018-07-17 10:30:37\ntags:\n---\n\n\tdelete node_modules\n\tnpm install hexo --save\n\n这里是第一段\n这里是第二段\n这个是一级标题\n===\n这个是二级标题\n---\n>这是一个块\n这是一个块\n这是一个块\n这是一个块\n>>这又是一个块\n这又是一个块\n这又是一个块\n这又是一个块\n\n- 无序列表\n- 无序列表\n- 无序列表\n+ 无序列表\n* 无序列表\n\n1. 有序列表\n1. 有序列表\n1. 有序列表\n\n1986\\. 转义点号防止变成列表\n\n    Hello World\n    这里是代码块\n    Bye Bye\n\n***\n---\n___\n\n*斜体*\n**粗体**\n~~删除线~~\n[超链接](http://www.google.cn/)\n\\##这不是二级标题\n\n| Item     | Value     | Qty   |\n| :------- | --------: | :---: |\n| Computer | 1600 USD  | 5     |\n| Phone    | 12 USD    | 12    |\n| Pipe     | 1 USD     | 234   |\n\n这是用```Hello World```表示的行内代码块","slug":"MarkDown","published":1,"updated":"2020-05-13T04:04:41.662Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka4xpxie00078st1u2xn67nt","content":"<pre><code>delete node_modules\nnpm install hexo --save</code></pre><p>这里是第一段<br>这里是第二段</p>\n<h1 id=\"这个是一级标题\"><a href=\"#这个是一级标题\" class=\"headerlink\" title=\"这个是一级标题\"></a>这个是一级标题</h1><h2 id=\"这个是二级标题\"><a href=\"#这个是二级标题\" class=\"headerlink\" title=\"这个是二级标题\"></a>这个是二级标题</h2><blockquote>\n<p>这是一个块<br>这是一个块<br>这是一个块<br>这是一个块</p>\n<blockquote>\n<p>这又是一个块<br>这又是一个块<br>这又是一个块<br>这又是一个块</p>\n</blockquote>\n</blockquote>\n<ul>\n<li>无序列表</li>\n<li>无序列表</li>\n<li>无序列表</li>\n</ul>\n<ul>\n<li>无序列表</li>\n</ul>\n<ul>\n<li>无序列表</li>\n</ul>\n<ol>\n<li>有序列表</li>\n<li>有序列表</li>\n<li>有序列表</li>\n</ol>\n<p>1986. 转义点号防止变成列表</p>\n<pre><code>Hello World\n这里是代码块\nBye Bye</code></pre><hr>\n<hr>\n<hr>\n<p><em>斜体</em><br><strong>粗体</strong><br><del>删除线</del><br><a href=\"http://www.google.cn/\" target=\"_blank\" rel=\"noopener\">超链接</a><br>##这不是二级标题</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Item</th>\n<th align=\"right\">Value</th>\n<th align=\"center\">Qty</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Computer</td>\n<td align=\"right\">1600 USD</td>\n<td align=\"center\">5</td>\n</tr>\n<tr>\n<td align=\"left\">Phone</td>\n<td align=\"right\">12 USD</td>\n<td align=\"center\">12</td>\n</tr>\n<tr>\n<td align=\"left\">Pipe</td>\n<td align=\"right\">1 USD</td>\n<td align=\"center\">234</td>\n</tr>\n</tbody></table>\n<p>这是用<code>Hello World</code>表示的行内代码块</p>\n","site":{"data":{}},"excerpt":"","more":"<pre><code>delete node_modules\nnpm install hexo --save</code></pre><p>这里是第一段<br>这里是第二段</p>\n<h1 id=\"这个是一级标题\"><a href=\"#这个是一级标题\" class=\"headerlink\" title=\"这个是一级标题\"></a>这个是一级标题</h1><h2 id=\"这个是二级标题\"><a href=\"#这个是二级标题\" class=\"headerlink\" title=\"这个是二级标题\"></a>这个是二级标题</h2><blockquote>\n<p>这是一个块<br>这是一个块<br>这是一个块<br>这是一个块</p>\n<blockquote>\n<p>这又是一个块<br>这又是一个块<br>这又是一个块<br>这又是一个块</p>\n</blockquote>\n</blockquote>\n<ul>\n<li>无序列表</li>\n<li>无序列表</li>\n<li>无序列表</li>\n</ul>\n<ul>\n<li>无序列表</li>\n</ul>\n<ul>\n<li>无序列表</li>\n</ul>\n<ol>\n<li>有序列表</li>\n<li>有序列表</li>\n<li>有序列表</li>\n</ol>\n<p>1986. 转义点号防止变成列表</p>\n<pre><code>Hello World\n这里是代码块\nBye Bye</code></pre><hr>\n<hr>\n<hr>\n<p><em>斜体</em><br><strong>粗体</strong><br><del>删除线</del><br><a href=\"http://www.google.cn/\" target=\"_blank\" rel=\"noopener\">超链接</a><br>##这不是二级标题</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Item</th>\n<th align=\"right\">Value</th>\n<th align=\"center\">Qty</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Computer</td>\n<td align=\"right\">1600 USD</td>\n<td align=\"center\">5</td>\n</tr>\n<tr>\n<td align=\"left\">Phone</td>\n<td align=\"right\">12 USD</td>\n<td align=\"center\">12</td>\n</tr>\n<tr>\n<td align=\"left\">Pipe</td>\n<td align=\"right\">1 USD</td>\n<td align=\"center\">234</td>\n</tr>\n</tbody></table>\n<p>这是用<code>Hello World</code>表示的行内代码块</p>\n"},{"title":"RTR - 04. Transforms","date":"2019-02-14T15:13:42.000Z","_content":"\n- 线性变换 linear transform: rotate / scale\n\t+ $ f(x) + f(y) = f(x+y) $\n\t+ $ kf(x) = f(kx) $\n- 仿射变换 affine transform: linear transform + move\n\t+ 保持平行线依旧平行，但是长度和角度不一定\n\n---\n\n#### OpenGL /  DirectX\n$$\\begin{array}{l|lll}\n\t\tOpenGL & right-handed & column-major & CBA \\vec v \\newline\n\t\tDirectX & left-handed & row-major & \\vec v ABC\n\\end{array}$$\n![](/images/RTR4_04_01.png)\n\n#### Translation \nOpenGL : column-major VS DirectX : row-major\n\n$$\n\\left[\n\t\\begin{array}{cccc}\n\t\t1 & 0 & 0 & t_x \\newline\n\t\t0 & 1 & 0 & t_y \\newline\n\t\t0 & 0 & 1 & t_z \\newline\n\t\t0 & 0 & 0 & 1\n\t\\end{array}\n\\right]\n\\*\n\\left[\n\t\\begin{array}{c}\n\t\tx \\newline\n\t\ty \\newline\n\t\tz \\newline\n\t\t1\n\t\\end{array}\n\\right]\nor\n\\left[\n\t\\begin{array}{cccc}\n\t\tx & y & z & 1\n\t\\end{array}\n\\right]\n\\*\n\\left[\n\t\\begin{array}{cccc}\n\t\t1 & 0 & 0 & 0 \\newline\n\t\t0 & 1 & 0 & 0 \\newline\n\t\t0 & 0 & 1 & 0 \\newline\n\t\tt_x & t_y & t_z & 1\n\t\\end{array}\n\\right]\n$$\ninverse matrix 逆矩阵: $ T^{-1}(t) = T(-t)$\n\n#### Rotation\n2 dimensions ( OpenGL ) :\n$$\\begin{bmatrix}\n\tcos\\theta & -sin\\theta \\newline\n\tsin\\theta & cos\\theta \\newline\n\\end{bmatrix}$$\n\n3 dimensions ( OpenGL ) :\n\n$$R_x(\\theta) = \n\\begin{bmatrix}\n\t1 & 0 & 0 & 0 \\newline\n\t0 & cos\\theta & -sin\\theta & 0 \\newline\n\t0 & sin\\theta & cos\\theta & 0 \\newline\n\t0 & 0 & 0 & 1 \n\\end{bmatrix}$$\n\n$$R_y(\\theta) = \n\\begin{bmatrix}\n\tcos\\theta & 0 & sin\\theta & 0 \\newline\n\t0 & 1 & 0 & 0 \\newline\n\t-sin\\theta & 0 & cos\\theta & 0 \\newline\n\t0 & 0 & 0 & 1 \n\\end{bmatrix}$$\n\n$$R_z(\\theta) = \n\\begin{bmatrix}\n\tcos\\theta & -sin\\theta & 0 & 0 \\newline\n\tsin\\theta & cos\\theta & 0 & 0 \\newline\n\t0 & 0 & 1 & 0 \\newline\n\t0 & 0 & 0 & 1\n\\end{bmatrix}$$\n\n逆矩阵: $ R_i^{-1}(\\theta) = R_i(-\\theta)$\n\nfor 3x3 rotation mateix, the **trace** ( the sum of the diagonal elements in a matrix ) is  constant :\n$ tr(R) = 1+2cos\\theta $\n\n#### Scaling\n$$\\begin{bmatrix}\n\tS_x & 0 & 0 & 0 \\newline\n\t0 & S_y & 0 & 0 \\newline\n\t0 & 0 & S_z & 0 \\newline\n\t0 & 0 & 0 & 1\n\\end{bmatrix}$$\n\n逆矩阵: $ S^{-1}(s) = S(\\frac{1}{S_x},\\frac{1}{S_y},\\frac{1}{S_z}) $\n\n- 如果有两项negative = > rotate $ \\pi $ radians\n- 如果有一项或三项negative => reflection matrix \n\t可能导致incorrect lighting或backface culling，需要先计算行列式determinant是否$<0$\n$$\n\\begin{array}{|lll|}\n\ta_1 & b1 & c1 \\newline\n\ta_2 & b2 & c2 \\newline\n\ta_3 & b3 & c3 \\newline\n\\end{array}\n= a_1b_2c_3 + b_1c_2a_3 + c_1a_2b_3 - a_3b_2c_1 - b_3c_2a_1 - c_3a_2b_1\n$$\n\n**TRS** is the order commonly used( OpenGL ),so **S** is applied first\n\n---\n\n其余等用到再看\n\n","source":"_posts/RTR-04.md","raw":"---\ntitle: RTR - 04. Transforms\ndate: 2019-02-14 23:13:42\ntags: Real Time Rendering\ncategories: Real Time Rendering\n---\n\n- 线性变换 linear transform: rotate / scale\n\t+ $ f(x) + f(y) = f(x+y) $\n\t+ $ kf(x) = f(kx) $\n- 仿射变换 affine transform: linear transform + move\n\t+ 保持平行线依旧平行，但是长度和角度不一定\n\n---\n\n#### OpenGL /  DirectX\n$$\\begin{array}{l|lll}\n\t\tOpenGL & right-handed & column-major & CBA \\vec v \\newline\n\t\tDirectX & left-handed & row-major & \\vec v ABC\n\\end{array}$$\n![](/images/RTR4_04_01.png)\n\n#### Translation \nOpenGL : column-major VS DirectX : row-major\n\n$$\n\\left[\n\t\\begin{array}{cccc}\n\t\t1 & 0 & 0 & t_x \\newline\n\t\t0 & 1 & 0 & t_y \\newline\n\t\t0 & 0 & 1 & t_z \\newline\n\t\t0 & 0 & 0 & 1\n\t\\end{array}\n\\right]\n\\*\n\\left[\n\t\\begin{array}{c}\n\t\tx \\newline\n\t\ty \\newline\n\t\tz \\newline\n\t\t1\n\t\\end{array}\n\\right]\nor\n\\left[\n\t\\begin{array}{cccc}\n\t\tx & y & z & 1\n\t\\end{array}\n\\right]\n\\*\n\\left[\n\t\\begin{array}{cccc}\n\t\t1 & 0 & 0 & 0 \\newline\n\t\t0 & 1 & 0 & 0 \\newline\n\t\t0 & 0 & 1 & 0 \\newline\n\t\tt_x & t_y & t_z & 1\n\t\\end{array}\n\\right]\n$$\ninverse matrix 逆矩阵: $ T^{-1}(t) = T(-t)$\n\n#### Rotation\n2 dimensions ( OpenGL ) :\n$$\\begin{bmatrix}\n\tcos\\theta & -sin\\theta \\newline\n\tsin\\theta & cos\\theta \\newline\n\\end{bmatrix}$$\n\n3 dimensions ( OpenGL ) :\n\n$$R_x(\\theta) = \n\\begin{bmatrix}\n\t1 & 0 & 0 & 0 \\newline\n\t0 & cos\\theta & -sin\\theta & 0 \\newline\n\t0 & sin\\theta & cos\\theta & 0 \\newline\n\t0 & 0 & 0 & 1 \n\\end{bmatrix}$$\n\n$$R_y(\\theta) = \n\\begin{bmatrix}\n\tcos\\theta & 0 & sin\\theta & 0 \\newline\n\t0 & 1 & 0 & 0 \\newline\n\t-sin\\theta & 0 & cos\\theta & 0 \\newline\n\t0 & 0 & 0 & 1 \n\\end{bmatrix}$$\n\n$$R_z(\\theta) = \n\\begin{bmatrix}\n\tcos\\theta & -sin\\theta & 0 & 0 \\newline\n\tsin\\theta & cos\\theta & 0 & 0 \\newline\n\t0 & 0 & 1 & 0 \\newline\n\t0 & 0 & 0 & 1\n\\end{bmatrix}$$\n\n逆矩阵: $ R_i^{-1}(\\theta) = R_i(-\\theta)$\n\nfor 3x3 rotation mateix, the **trace** ( the sum of the diagonal elements in a matrix ) is  constant :\n$ tr(R) = 1+2cos\\theta $\n\n#### Scaling\n$$\\begin{bmatrix}\n\tS_x & 0 & 0 & 0 \\newline\n\t0 & S_y & 0 & 0 \\newline\n\t0 & 0 & S_z & 0 \\newline\n\t0 & 0 & 0 & 1\n\\end{bmatrix}$$\n\n逆矩阵: $ S^{-1}(s) = S(\\frac{1}{S_x},\\frac{1}{S_y},\\frac{1}{S_z}) $\n\n- 如果有两项negative = > rotate $ \\pi $ radians\n- 如果有一项或三项negative => reflection matrix \n\t可能导致incorrect lighting或backface culling，需要先计算行列式determinant是否$<0$\n$$\n\\begin{array}{|lll|}\n\ta_1 & b1 & c1 \\newline\n\ta_2 & b2 & c2 \\newline\n\ta_3 & b3 & c3 \\newline\n\\end{array}\n= a_1b_2c_3 + b_1c_2a_3 + c_1a_2b_3 - a_3b_2c_1 - b_3c_2a_1 - c_3a_2b_1\n$$\n\n**TRS** is the order commonly used( OpenGL ),so **S** is applied first\n\n---\n\n其余等用到再看\n\n","slug":"RTR-04","published":1,"updated":"2020-05-13T04:04:41.663Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka4xpxij000b8st10b4whpmj","content":"<ul>\n<li>线性变换 linear transform: rotate / scale<ul>\n<li>$ f(x) + f(y) = f(x+y) $</li>\n<li>$ kf(x) = f(kx) $</li>\n</ul>\n</li>\n<li>仿射变换 affine transform: linear transform + move<ul>\n<li>保持平行线依旧平行，但是长度和角度不一定</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h4 id=\"OpenGL-DirectX\"><a href=\"#OpenGL-DirectX\" class=\"headerlink\" title=\"OpenGL /  DirectX\"></a>OpenGL /  DirectX</h4><p>$$\\begin{array}{l|lll}<br>        OpenGL &amp; right-handed &amp; column-major &amp; CBA \\vec v \\newline<br>        DirectX &amp; left-handed &amp; row-major &amp; \\vec v ABC<br>\\end{array}$$<br><img src=\"/images/RTR4_04_01.png\" alt></p>\n<h4 id=\"Translation\"><a href=\"#Translation\" class=\"headerlink\" title=\"Translation\"></a>Translation</h4><p>OpenGL : column-major VS DirectX : row-major</p>\n<p>$$<br>\\left[<br>    \\begin{array}{cccc}<br>        1 &amp; 0 &amp; 0 &amp; t_x \\newline<br>        0 &amp; 1 &amp; 0 &amp; t_y \\newline<br>        0 &amp; 0 &amp; 1 &amp; t_z \\newline<br>        0 &amp; 0 &amp; 0 &amp; 1<br>    \\end{array}<br>\\right]<br>*<br>\\left[<br>    \\begin{array}{c}<br>        x \\newline<br>        y \\newline<br>        z \\newline<br>        1<br>    \\end{array}<br>\\right]<br>or<br>\\left[<br>    \\begin{array}{cccc}<br>        x &amp; y &amp; z &amp; 1<br>    \\end{array}<br>\\right]<br>*<br>\\left[<br>    \\begin{array}{cccc}<br>        1 &amp; 0 &amp; 0 &amp; 0 \\newline<br>        0 &amp; 1 &amp; 0 &amp; 0 \\newline<br>        0 &amp; 0 &amp; 1 &amp; 0 \\newline<br>        t_x &amp; t_y &amp; t_z &amp; 1<br>    \\end{array}<br>\\right]<br>$$<br>inverse matrix 逆矩阵: $ T^{-1}(t) = T(-t)$</p>\n<h4 id=\"Rotation\"><a href=\"#Rotation\" class=\"headerlink\" title=\"Rotation\"></a>Rotation</h4><p>2 dimensions ( OpenGL ) :<br>$$\\begin{bmatrix}<br>    cos\\theta &amp; -sin\\theta \\newline<br>    sin\\theta &amp; cos\\theta \\newline<br>\\end{bmatrix}$$</p>\n<p>3 dimensions ( OpenGL ) :</p>\n<p>$$R_x(\\theta) =<br>\\begin{bmatrix}<br>    1 &amp; 0 &amp; 0 &amp; 0 \\newline<br>    0 &amp; cos\\theta &amp; -sin\\theta &amp; 0 \\newline<br>    0 &amp; sin\\theta &amp; cos\\theta &amp; 0 \\newline<br>    0 &amp; 0 &amp; 0 &amp; 1<br>\\end{bmatrix}$$</p>\n<p>$$R_y(\\theta) =<br>\\begin{bmatrix}<br>    cos\\theta &amp; 0 &amp; sin\\theta &amp; 0 \\newline<br>    0 &amp; 1 &amp; 0 &amp; 0 \\newline<br>    -sin\\theta &amp; 0 &amp; cos\\theta &amp; 0 \\newline<br>    0 &amp; 0 &amp; 0 &amp; 1<br>\\end{bmatrix}$$</p>\n<p>$$R_z(\\theta) =<br>\\begin{bmatrix}<br>    cos\\theta &amp; -sin\\theta &amp; 0 &amp; 0 \\newline<br>    sin\\theta &amp; cos\\theta &amp; 0 &amp; 0 \\newline<br>    0 &amp; 0 &amp; 1 &amp; 0 \\newline<br>    0 &amp; 0 &amp; 0 &amp; 1<br>\\end{bmatrix}$$</p>\n<p>逆矩阵: $ R_i^{-1}(\\theta) = R_i(-\\theta)$</p>\n<p>for 3x3 rotation mateix, the <strong>trace</strong> ( the sum of the diagonal elements in a matrix ) is  constant :<br>$ tr(R) = 1+2cos\\theta $</p>\n<h4 id=\"Scaling\"><a href=\"#Scaling\" class=\"headerlink\" title=\"Scaling\"></a>Scaling</h4><p>$$\\begin{bmatrix}<br>    S_x &amp; 0 &amp; 0 &amp; 0 \\newline<br>    0 &amp; S_y &amp; 0 &amp; 0 \\newline<br>    0 &amp; 0 &amp; S_z &amp; 0 \\newline<br>    0 &amp; 0 &amp; 0 &amp; 1<br>\\end{bmatrix}$$</p>\n<p>逆矩阵: $ S^{-1}(s) = S(\\frac{1}{S_x},\\frac{1}{S_y},\\frac{1}{S_z}) $</p>\n<ul>\n<li>如果有两项negative = &gt; rotate $ \\pi $ radians</li>\n<li>如果有一项或三项negative =&gt; reflection matrix<br>  可能导致incorrect lighting或backface culling，需要先计算行列式determinant是否$&lt;0$<br>$$<br>\\begin{array}{|lll|}<br>  a_1 &amp; b1 &amp; c1 \\newline<br>  a_2 &amp; b2 &amp; c2 \\newline<br>  a_3 &amp; b3 &amp; c3 \\newline<br>\\end{array}<br>= a_1b_2c_3 + b_1c_2a_3 + c_1a_2b_3 - a_3b_2c_1 - b_3c_2a_1 - c_3a_2b_1<br>$$</li>\n</ul>\n<p><strong>TRS</strong> is the order commonly used( OpenGL ),so <strong>S</strong> is applied first</p>\n<hr>\n<p>其余等用到再看</p>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>线性变换 linear transform: rotate / scale<ul>\n<li>$ f(x) + f(y) = f(x+y) $</li>\n<li>$ kf(x) = f(kx) $</li>\n</ul>\n</li>\n<li>仿射变换 affine transform: linear transform + move<ul>\n<li>保持平行线依旧平行，但是长度和角度不一定</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h4 id=\"OpenGL-DirectX\"><a href=\"#OpenGL-DirectX\" class=\"headerlink\" title=\"OpenGL /  DirectX\"></a>OpenGL /  DirectX</h4><p>$$\\begin{array}{l|lll}<br>        OpenGL &amp; right-handed &amp; column-major &amp; CBA \\vec v \\newline<br>        DirectX &amp; left-handed &amp; row-major &amp; \\vec v ABC<br>\\end{array}$$<br><img src=\"/images/RTR4_04_01.png\" alt></p>\n<h4 id=\"Translation\"><a href=\"#Translation\" class=\"headerlink\" title=\"Translation\"></a>Translation</h4><p>OpenGL : column-major VS DirectX : row-major</p>\n<p>$$<br>\\left[<br>    \\begin{array}{cccc}<br>        1 &amp; 0 &amp; 0 &amp; t_x \\newline<br>        0 &amp; 1 &amp; 0 &amp; t_y \\newline<br>        0 &amp; 0 &amp; 1 &amp; t_z \\newline<br>        0 &amp; 0 &amp; 0 &amp; 1<br>    \\end{array}<br>\\right]<br>*<br>\\left[<br>    \\begin{array}{c}<br>        x \\newline<br>        y \\newline<br>        z \\newline<br>        1<br>    \\end{array}<br>\\right]<br>or<br>\\left[<br>    \\begin{array}{cccc}<br>        x &amp; y &amp; z &amp; 1<br>    \\end{array}<br>\\right]<br>*<br>\\left[<br>    \\begin{array}{cccc}<br>        1 &amp; 0 &amp; 0 &amp; 0 \\newline<br>        0 &amp; 1 &amp; 0 &amp; 0 \\newline<br>        0 &amp; 0 &amp; 1 &amp; 0 \\newline<br>        t_x &amp; t_y &amp; t_z &amp; 1<br>    \\end{array}<br>\\right]<br>$$<br>inverse matrix 逆矩阵: $ T^{-1}(t) = T(-t)$</p>\n<h4 id=\"Rotation\"><a href=\"#Rotation\" class=\"headerlink\" title=\"Rotation\"></a>Rotation</h4><p>2 dimensions ( OpenGL ) :<br>$$\\begin{bmatrix}<br>    cos\\theta &amp; -sin\\theta \\newline<br>    sin\\theta &amp; cos\\theta \\newline<br>\\end{bmatrix}$$</p>\n<p>3 dimensions ( OpenGL ) :</p>\n<p>$$R_x(\\theta) =<br>\\begin{bmatrix}<br>    1 &amp; 0 &amp; 0 &amp; 0 \\newline<br>    0 &amp; cos\\theta &amp; -sin\\theta &amp; 0 \\newline<br>    0 &amp; sin\\theta &amp; cos\\theta &amp; 0 \\newline<br>    0 &amp; 0 &amp; 0 &amp; 1<br>\\end{bmatrix}$$</p>\n<p>$$R_y(\\theta) =<br>\\begin{bmatrix}<br>    cos\\theta &amp; 0 &amp; sin\\theta &amp; 0 \\newline<br>    0 &amp; 1 &amp; 0 &amp; 0 \\newline<br>    -sin\\theta &amp; 0 &amp; cos\\theta &amp; 0 \\newline<br>    0 &amp; 0 &amp; 0 &amp; 1<br>\\end{bmatrix}$$</p>\n<p>$$R_z(\\theta) =<br>\\begin{bmatrix}<br>    cos\\theta &amp; -sin\\theta &amp; 0 &amp; 0 \\newline<br>    sin\\theta &amp; cos\\theta &amp; 0 &amp; 0 \\newline<br>    0 &amp; 0 &amp; 1 &amp; 0 \\newline<br>    0 &amp; 0 &amp; 0 &amp; 1<br>\\end{bmatrix}$$</p>\n<p>逆矩阵: $ R_i^{-1}(\\theta) = R_i(-\\theta)$</p>\n<p>for 3x3 rotation mateix, the <strong>trace</strong> ( the sum of the diagonal elements in a matrix ) is  constant :<br>$ tr(R) = 1+2cos\\theta $</p>\n<h4 id=\"Scaling\"><a href=\"#Scaling\" class=\"headerlink\" title=\"Scaling\"></a>Scaling</h4><p>$$\\begin{bmatrix}<br>    S_x &amp; 0 &amp; 0 &amp; 0 \\newline<br>    0 &amp; S_y &amp; 0 &amp; 0 \\newline<br>    0 &amp; 0 &amp; S_z &amp; 0 \\newline<br>    0 &amp; 0 &amp; 0 &amp; 1<br>\\end{bmatrix}$$</p>\n<p>逆矩阵: $ S^{-1}(s) = S(\\frac{1}{S_x},\\frac{1}{S_y},\\frac{1}{S_z}) $</p>\n<ul>\n<li>如果有两项negative = &gt; rotate $ \\pi $ radians</li>\n<li>如果有一项或三项negative =&gt; reflection matrix<br>  可能导致incorrect lighting或backface culling，需要先计算行列式determinant是否$&lt;0$<br>$$<br>\\begin{array}{|lll|}<br>  a_1 &amp; b1 &amp; c1 \\newline<br>  a_2 &amp; b2 &amp; c2 \\newline<br>  a_3 &amp; b3 &amp; c3 \\newline<br>\\end{array}<br>= a_1b_2c_3 + b_1c_2a_3 + c_1a_2b_3 - a_3b_2c_1 - b_3c_2a_1 - c_3a_2b_1<br>$$</li>\n</ul>\n<p><strong>TRS</strong> is the order commonly used( OpenGL ),so <strong>S</strong> is applied first</p>\n<hr>\n<p>其余等用到再看</p>\n"},{"title":"Shadertoy - 01. Ray Tracing","date":"2019-01-28T08:41:38.000Z","_content":"\n![](/images/Shadertoy_01_01.png)\n[Shadertoy源码下载](/codes/RayTracing.glsl)\n\n---\n\n光线追踪，基本思想是从摄像机的位置向屏幕发射光线，然后检测在场景中是否和物体相交\n![](http://www.scratchapixel.com/images/upload/ray-tracing-refresher/rt-setup2.png?)\n\n#### 实现思路\n1. 设置参数搭建场景\n2. 发射光线，检测是否和物体相交\n3. 计算最终颜色\n\n因为需要先了解如何检测相交才能决定需要哪些参数，所以先看下如何检测相交\n\n本文坐标系如下，不涉及空间转换\n注意： 屏幕坐标系的Z轴正方向应该是垂直于屏幕向里，和图上相反\n但是因为后面的光照模型是直接搬的别人的代码，光源位置在轴向向外的情况下显示正常\n所以就按照Z轴向外放置摄像机和场景了\n\n![](/images/Shadertoy_01_05.png)\n\n#### 如何检测相交\n\n##### 如何检测和球体相交\n光线可以用 $ r_0+t\\*rd $ 来表示 ( 光线起始位置 + 长度 \\* 单位方向向量 )\n![](http://www.scratchapixel.com/images/upload/ray-simple-shapes/impsurf-ray.png?)\n同时，在球面上的每一点到球心的距离都等于球的半径\n所以光线和球的交点必定满足$ | r_0 + t\\*rd - center |= R $（ $ r_0, rd, center $都是$ vec3 $ ）\n为了避免开方的计算，我们把两边都平方，得到$ ( r_0 + t\\*rd - center )^2 = R^2 $\n这里面$ r_0 $是摄像机的位置，$ rd $是光线方向，$ center $是球心坐标，$ R $是球的半径\n只有$ t $是未知的，是我们需要求解的变量，如果$ t $有解，说明光线和球体相交\n\n重新整理等式，$ [ rd\\*t + ( r_0 - center )]^2 = R^2$ \n展开为$ rd^2t^2 + 2rd( r_0 - center )t + (r_0 - center)^2 - R^2 = 0 $\n因为$ rd $是单位向量，所以$ rd^2 = 1 $\n=> $ t^2 + 2rd( r_0 - center )t + (r_0 - center)^2 - R^2 = 0 $\n\n总所周知，一元二次方程的求解公式 $ x = \\frac { -b ± \\sqrt{b^2-4ac} } { 2a } $\nif $ b^2-4ac < 0 $, 无解\n```\n//sph.xyz: center， sph.w: radius\nfloat iSphere(in vec3 ro, in vec3 rd, in vec4 sph)\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd ); \n    float c = dot(oc,oc) - sph.w*sph.w;\n    float h = b*b - c; \n    if( h < 0.0 ) return -1.0;\n    float t = -b - sqrt(h);\n    return t;\n}\n```\n\n##### 如何检测和平面相交\n注意这里是指无限大的平面，不是有边界的矩形\n![](http://www.scratchapixel.com/images/upload/ray-simple-shapes/plane.png?)\n我们需要的是xz方向的平面，平面上任意一点可以表示为（0，h，0）\n如果相交，光线和平面的交点$P$到平面上任意一点$P_0$的向量必定和平面法线$n$垂直\n也就是$PP_0 ·n = 0$ \n=> $ [r_0+t\\*rd - (0,h,0)] * (0,1,0) = 0 $, 得到 $ t = \\frac{h - r_0.y}{rd.y} $\n```\nfloat iPlane(in vec3 ro, in vec3 rd, in float h) \n{\n    return (h-ro.y)/rd.y;\n}\n```\n\n#### 设置参数搭建场景\n了解如何检测相交之后，我们就知道了要提供哪些参数\n$ r_0 $：摄像机的位置，$ rd $：光线方向，$ center $：球心坐标，$ R $：球的半径\n\n如图所示，$ rd $的集合其实就是这个摄像机视锥，反映了焦距，FOV等\n而$ r_0 $其实是前后移动摄像机以及视锥，等于摄像机和视锥不动，物体前后移动\n并不影响透视，镜头拉伸等效果\n![](/images/Shadertoy_01_02.gif)\n\n把屏幕坐标转换到[-1,1]，乘以屏幕长宽比确保不会拉伸，这个就是视锥底面的尺寸\n```\t\nvec2 uv = (fragCoord * 2.0 - iResolution.xy ) / iResolution.y\n```\n而视锥的长度，即$ rd.z $代表了相机的焦距，会影响到最终画面的透视效果\n\n![rd.z = 2.14的时候](/images/Shadertoy_01_01.png)\n![rd.z = 1.0的时候](/images/Shadertoy_01_03.png)\n这里的2.14是根据[Jqx1991的回答](https://www.zhihu.com/question/20086562)模拟人眼透视\n视锥角度为25°, 屏幕高度为1，$ \\frac {1}{tan25°} ≈ 2.14 $\n调节$ rd.z $可以看到透视慢慢转向广角镜头或者鱼眼镜头的效果\n![](/images/Shadertoy_01_04.png)\n```\nvec3 rd = normalize( vec3(uv, -2.14) )\n```\n定义球比较简单，$ xyz $是球心坐标，$ w $是半径\n``` \nvec4 s1 = vec4(  0.0, 0.0, -5.0, 1.0 )\n```\n\n#### 计算最终颜色\n前面检测相交的函数返回了$ t $\n因为是从摄像机发出光线射向屏幕，所以交点一定是在摄像机前面，即$ t >0 $\n光线和三个球体以及平面分别进行相交检测，然后得到最小的$ t $值即最近的交点\n最开始说过，光线用 $ r_0+t\\*rd $ 来表示，得到$ t $之后代入，得到交点的坐标信息\n球体的法线就是从球心到交点向外，平面的法线就是竖直向上\n然后进行光照计算得到最终结果，这里直接采用了[EKnapik](https://www.shadertoy.com/view/MllSRj)的代码\n\n\n#### 参考资料\n[Ray-Tracer](http://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/parametric-and-implicit-surfaces)\n[成像视角](https://www.zhihu.com/question/20086562)\n[光照模型](https://www.shadertoy.com/view/MllSRj)","source":"_posts/Shadertoy-01.md","raw":"---\ntitle: Shadertoy - 01. Ray Tracing\ndate: 2019-01-28 16:41:38\ntags: Shader\ncategories: Shader\n---\n\n![](/images/Shadertoy_01_01.png)\n[Shadertoy源码下载](/codes/RayTracing.glsl)\n\n---\n\n光线追踪，基本思想是从摄像机的位置向屏幕发射光线，然后检测在场景中是否和物体相交\n![](http://www.scratchapixel.com/images/upload/ray-tracing-refresher/rt-setup2.png?)\n\n#### 实现思路\n1. 设置参数搭建场景\n2. 发射光线，检测是否和物体相交\n3. 计算最终颜色\n\n因为需要先了解如何检测相交才能决定需要哪些参数，所以先看下如何检测相交\n\n本文坐标系如下，不涉及空间转换\n注意： 屏幕坐标系的Z轴正方向应该是垂直于屏幕向里，和图上相反\n但是因为后面的光照模型是直接搬的别人的代码，光源位置在轴向向外的情况下显示正常\n所以就按照Z轴向外放置摄像机和场景了\n\n![](/images/Shadertoy_01_05.png)\n\n#### 如何检测相交\n\n##### 如何检测和球体相交\n光线可以用 $ r_0+t\\*rd $ 来表示 ( 光线起始位置 + 长度 \\* 单位方向向量 )\n![](http://www.scratchapixel.com/images/upload/ray-simple-shapes/impsurf-ray.png?)\n同时，在球面上的每一点到球心的距离都等于球的半径\n所以光线和球的交点必定满足$ | r_0 + t\\*rd - center |= R $（ $ r_0, rd, center $都是$ vec3 $ ）\n为了避免开方的计算，我们把两边都平方，得到$ ( r_0 + t\\*rd - center )^2 = R^2 $\n这里面$ r_0 $是摄像机的位置，$ rd $是光线方向，$ center $是球心坐标，$ R $是球的半径\n只有$ t $是未知的，是我们需要求解的变量，如果$ t $有解，说明光线和球体相交\n\n重新整理等式，$ [ rd\\*t + ( r_0 - center )]^2 = R^2$ \n展开为$ rd^2t^2 + 2rd( r_0 - center )t + (r_0 - center)^2 - R^2 = 0 $\n因为$ rd $是单位向量，所以$ rd^2 = 1 $\n=> $ t^2 + 2rd( r_0 - center )t + (r_0 - center)^2 - R^2 = 0 $\n\n总所周知，一元二次方程的求解公式 $ x = \\frac { -b ± \\sqrt{b^2-4ac} } { 2a } $\nif $ b^2-4ac < 0 $, 无解\n```\n//sph.xyz: center， sph.w: radius\nfloat iSphere(in vec3 ro, in vec3 rd, in vec4 sph)\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd ); \n    float c = dot(oc,oc) - sph.w*sph.w;\n    float h = b*b - c; \n    if( h < 0.0 ) return -1.0;\n    float t = -b - sqrt(h);\n    return t;\n}\n```\n\n##### 如何检测和平面相交\n注意这里是指无限大的平面，不是有边界的矩形\n![](http://www.scratchapixel.com/images/upload/ray-simple-shapes/plane.png?)\n我们需要的是xz方向的平面，平面上任意一点可以表示为（0，h，0）\n如果相交，光线和平面的交点$P$到平面上任意一点$P_0$的向量必定和平面法线$n$垂直\n也就是$PP_0 ·n = 0$ \n=> $ [r_0+t\\*rd - (0,h,0)] * (0,1,0) = 0 $, 得到 $ t = \\frac{h - r_0.y}{rd.y} $\n```\nfloat iPlane(in vec3 ro, in vec3 rd, in float h) \n{\n    return (h-ro.y)/rd.y;\n}\n```\n\n#### 设置参数搭建场景\n了解如何检测相交之后，我们就知道了要提供哪些参数\n$ r_0 $：摄像机的位置，$ rd $：光线方向，$ center $：球心坐标，$ R $：球的半径\n\n如图所示，$ rd $的集合其实就是这个摄像机视锥，反映了焦距，FOV等\n而$ r_0 $其实是前后移动摄像机以及视锥，等于摄像机和视锥不动，物体前后移动\n并不影响透视，镜头拉伸等效果\n![](/images/Shadertoy_01_02.gif)\n\n把屏幕坐标转换到[-1,1]，乘以屏幕长宽比确保不会拉伸，这个就是视锥底面的尺寸\n```\t\nvec2 uv = (fragCoord * 2.0 - iResolution.xy ) / iResolution.y\n```\n而视锥的长度，即$ rd.z $代表了相机的焦距，会影响到最终画面的透视效果\n\n![rd.z = 2.14的时候](/images/Shadertoy_01_01.png)\n![rd.z = 1.0的时候](/images/Shadertoy_01_03.png)\n这里的2.14是根据[Jqx1991的回答](https://www.zhihu.com/question/20086562)模拟人眼透视\n视锥角度为25°, 屏幕高度为1，$ \\frac {1}{tan25°} ≈ 2.14 $\n调节$ rd.z $可以看到透视慢慢转向广角镜头或者鱼眼镜头的效果\n![](/images/Shadertoy_01_04.png)\n```\nvec3 rd = normalize( vec3(uv, -2.14) )\n```\n定义球比较简单，$ xyz $是球心坐标，$ w $是半径\n``` \nvec4 s1 = vec4(  0.0, 0.0, -5.0, 1.0 )\n```\n\n#### 计算最终颜色\n前面检测相交的函数返回了$ t $\n因为是从摄像机发出光线射向屏幕，所以交点一定是在摄像机前面，即$ t >0 $\n光线和三个球体以及平面分别进行相交检测，然后得到最小的$ t $值即最近的交点\n最开始说过，光线用 $ r_0+t\\*rd $ 来表示，得到$ t $之后代入，得到交点的坐标信息\n球体的法线就是从球心到交点向外，平面的法线就是竖直向上\n然后进行光照计算得到最终结果，这里直接采用了[EKnapik](https://www.shadertoy.com/view/MllSRj)的代码\n\n\n#### 参考资料\n[Ray-Tracer](http://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/parametric-and-implicit-surfaces)\n[成像视角](https://www.zhihu.com/question/20086562)\n[光照模型](https://www.shadertoy.com/view/MllSRj)","slug":"Shadertoy-01","published":1,"updated":"2020-05-13T04:04:41.664Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka4xpxil000c8st1h1vvs6o2","content":"<p><img src=\"/images/Shadertoy_01_01.png\" alt><br><a href=\"/codes/RayTracing.glsl\">Shadertoy源码下载</a></p>\n<hr>\n<p>光线追踪，基本思想是从摄像机的位置向屏幕发射光线，然后检测在场景中是否和物体相交<br><img src=\"http://www.scratchapixel.com/images/upload/ray-tracing-refresher/rt-setup2.png?\" alt></p>\n<h4 id=\"实现思路\"><a href=\"#实现思路\" class=\"headerlink\" title=\"实现思路\"></a>实现思路</h4><ol>\n<li>设置参数搭建场景</li>\n<li>发射光线，检测是否和物体相交</li>\n<li>计算最终颜色</li>\n</ol>\n<p>因为需要先了解如何检测相交才能决定需要哪些参数，所以先看下如何检测相交</p>\n<p>本文坐标系如下，不涉及空间转换<br>注意： 屏幕坐标系的Z轴正方向应该是垂直于屏幕向里，和图上相反<br>但是因为后面的光照模型是直接搬的别人的代码，光源位置在轴向向外的情况下显示正常<br>所以就按照Z轴向外放置摄像机和场景了</p>\n<p><img src=\"/images/Shadertoy_01_05.png\" alt></p>\n<h4 id=\"如何检测相交\"><a href=\"#如何检测相交\" class=\"headerlink\" title=\"如何检测相交\"></a>如何检测相交</h4><h5 id=\"如何检测和球体相交\"><a href=\"#如何检测和球体相交\" class=\"headerlink\" title=\"如何检测和球体相交\"></a>如何检测和球体相交</h5><p>光线可以用 $ r_0+t*rd $ 来表示 ( 光线起始位置 + 长度 * 单位方向向量 )<br><img src=\"http://www.scratchapixel.com/images/upload/ray-simple-shapes/impsurf-ray.png?\" alt><br>同时，在球面上的每一点到球心的距离都等于球的半径<br>所以光线和球的交点必定满足$ | r_0 + t*rd - center |= R $（ $ r_0, rd, center $都是$ vec3 $ ）<br>为了避免开方的计算，我们把两边都平方，得到$ ( r_0 + t*rd - center )^2 = R^2 $<br>这里面$ r_0 $是摄像机的位置，$ rd $是光线方向，$ center $是球心坐标，$ R $是球的半径<br>只有$ t $是未知的，是我们需要求解的变量，如果$ t $有解，说明光线和球体相交</p>\n<p>重新整理等式，$ [ rd*t + ( r_0 - center )]^2 = R^2$<br>展开为$ rd^2t^2 + 2rd( r_0 - center )t + (r_0 - center)^2 - R^2 = 0 $<br>因为$ rd $是单位向量，所以$ rd^2 = 1 $<br>=&gt; $ t^2 + 2rd( r_0 - center )t + (r_0 - center)^2 - R^2 = 0 $</p>\n<p>总所周知，一元二次方程的求解公式 $ x = \\frac { -b ± \\sqrt{b^2-4ac} } { 2a } $<br>if $ b^2-4ac &lt; 0 $, 无解</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//sph.xyz: center， sph.w: radius</span><br><span class=\"line\">float iSphere(in vec3 ro, in vec3 rd, in vec4 sph)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    vec3 oc = ro - sph.xyz;</span><br><span class=\"line\">    float b = dot( oc, rd ); </span><br><span class=\"line\">    float c = dot(oc,oc) - sph.w*sph.w;</span><br><span class=\"line\">    float h = b*b - c; </span><br><span class=\"line\">    if( h &lt; 0.0 ) return -1.0;</span><br><span class=\"line\">    float t = -b - sqrt(h);</span><br><span class=\"line\">    return t;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"如何检测和平面相交\"><a href=\"#如何检测和平面相交\" class=\"headerlink\" title=\"如何检测和平面相交\"></a>如何检测和平面相交</h5><p>注意这里是指无限大的平面，不是有边界的矩形<br><img src=\"http://www.scratchapixel.com/images/upload/ray-simple-shapes/plane.png?\" alt><br>我们需要的是xz方向的平面，平面上任意一点可以表示为（0，h，0）<br>如果相交，光线和平面的交点$P$到平面上任意一点$P_0$的向量必定和平面法线$n$垂直<br>也就是$PP_0 ·n = 0$<br>=&gt; $ [r_0+t*rd - (0,h,0)] * (0,1,0) = 0 $, 得到 $ t = \\frac{h - r_0.y}{rd.y} $</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">float iPlane(in vec3 ro, in vec3 rd, in float h) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return (h-ro.y)/rd.y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"设置参数搭建场景\"><a href=\"#设置参数搭建场景\" class=\"headerlink\" title=\"设置参数搭建场景\"></a>设置参数搭建场景</h4><p>了解如何检测相交之后，我们就知道了要提供哪些参数<br>$ r_0 $：摄像机的位置，$ rd $：光线方向，$ center $：球心坐标，$ R $：球的半径</p>\n<p>如图所示，$ rd $的集合其实就是这个摄像机视锥，反映了焦距，FOV等<br>而$ r_0 $其实是前后移动摄像机以及视锥，等于摄像机和视锥不动，物体前后移动<br>并不影响透视，镜头拉伸等效果<br><img src=\"/images/Shadertoy_01_02.gif\" alt></p>\n<p>把屏幕坐标转换到[-1,1]，乘以屏幕长宽比确保不会拉伸，这个就是视锥底面的尺寸</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec2 uv = (fragCoord * 2.0 - iResolution.xy ) / iResolution.y</span><br></pre></td></tr></table></figure>\n\n<p>而视锥的长度，即$ rd.z $代表了相机的焦距，会影响到最终画面的透视效果</p>\n<p><img src=\"/images/Shadertoy_01_01.png\" alt=\"rd.z = 2.14的时候\"><br><img src=\"/images/Shadertoy_01_03.png\" alt=\"rd.z = 1.0的时候\"><br>这里的2.14是根据<a href=\"https://www.zhihu.com/question/20086562\" target=\"_blank\" rel=\"noopener\">Jqx1991的回答</a>模拟人眼透视<br>视锥角度为25°, 屏幕高度为1，$ \\frac {1}{tan25°} ≈ 2.14 $<br>调节$ rd.z $可以看到透视慢慢转向广角镜头或者鱼眼镜头的效果<br><img src=\"/images/Shadertoy_01_04.png\" alt></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec3 rd = normalize( vec3(uv, -2.14) )</span><br></pre></td></tr></table></figure>\n\n<p>定义球比较简单，$ xyz $是球心坐标，$ w $是半径</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec4 s1 = vec4(  0.0, 0.0, -5.0, 1.0 )</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"计算最终颜色\"><a href=\"#计算最终颜色\" class=\"headerlink\" title=\"计算最终颜色\"></a>计算最终颜色</h4><p>前面检测相交的函数返回了$ t $<br>因为是从摄像机发出光线射向屏幕，所以交点一定是在摄像机前面，即$ t &gt;0 $<br>光线和三个球体以及平面分别进行相交检测，然后得到最小的$ t $值即最近的交点<br>最开始说过，光线用 $ r_0+t*rd $ 来表示，得到$ t $之后代入，得到交点的坐标信息<br>球体的法线就是从球心到交点向外，平面的法线就是竖直向上<br>然后进行光照计算得到最终结果，这里直接采用了<a href=\"https://www.shadertoy.com/view/MllSRj\" target=\"_blank\" rel=\"noopener\">EKnapik</a>的代码</p>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><p><a href=\"http://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/parametric-and-implicit-surfaces\" target=\"_blank\" rel=\"noopener\">Ray-Tracer</a><br><a href=\"https://www.zhihu.com/question/20086562\" target=\"_blank\" rel=\"noopener\">成像视角</a><br><a href=\"https://www.shadertoy.com/view/MllSRj\" target=\"_blank\" rel=\"noopener\">光照模型</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/Shadertoy_01_01.png\" alt><br><a href=\"/codes/RayTracing.glsl\">Shadertoy源码下载</a></p>\n<hr>\n<p>光线追踪，基本思想是从摄像机的位置向屏幕发射光线，然后检测在场景中是否和物体相交<br><img src=\"http://www.scratchapixel.com/images/upload/ray-tracing-refresher/rt-setup2.png?\" alt></p>\n<h4 id=\"实现思路\"><a href=\"#实现思路\" class=\"headerlink\" title=\"实现思路\"></a>实现思路</h4><ol>\n<li>设置参数搭建场景</li>\n<li>发射光线，检测是否和物体相交</li>\n<li>计算最终颜色</li>\n</ol>\n<p>因为需要先了解如何检测相交才能决定需要哪些参数，所以先看下如何检测相交</p>\n<p>本文坐标系如下，不涉及空间转换<br>注意： 屏幕坐标系的Z轴正方向应该是垂直于屏幕向里，和图上相反<br>但是因为后面的光照模型是直接搬的别人的代码，光源位置在轴向向外的情况下显示正常<br>所以就按照Z轴向外放置摄像机和场景了</p>\n<p><img src=\"/images/Shadertoy_01_05.png\" alt></p>\n<h4 id=\"如何检测相交\"><a href=\"#如何检测相交\" class=\"headerlink\" title=\"如何检测相交\"></a>如何检测相交</h4><h5 id=\"如何检测和球体相交\"><a href=\"#如何检测和球体相交\" class=\"headerlink\" title=\"如何检测和球体相交\"></a>如何检测和球体相交</h5><p>光线可以用 $ r_0+t*rd $ 来表示 ( 光线起始位置 + 长度 * 单位方向向量 )<br><img src=\"http://www.scratchapixel.com/images/upload/ray-simple-shapes/impsurf-ray.png?\" alt><br>同时，在球面上的每一点到球心的距离都等于球的半径<br>所以光线和球的交点必定满足$ | r_0 + t*rd - center |= R $（ $ r_0, rd, center $都是$ vec3 $ ）<br>为了避免开方的计算，我们把两边都平方，得到$ ( r_0 + t*rd - center )^2 = R^2 $<br>这里面$ r_0 $是摄像机的位置，$ rd $是光线方向，$ center $是球心坐标，$ R $是球的半径<br>只有$ t $是未知的，是我们需要求解的变量，如果$ t $有解，说明光线和球体相交</p>\n<p>重新整理等式，$ [ rd*t + ( r_0 - center )]^2 = R^2$<br>展开为$ rd^2t^2 + 2rd( r_0 - center )t + (r_0 - center)^2 - R^2 = 0 $<br>因为$ rd $是单位向量，所以$ rd^2 = 1 $<br>=&gt; $ t^2 + 2rd( r_0 - center )t + (r_0 - center)^2 - R^2 = 0 $</p>\n<p>总所周知，一元二次方程的求解公式 $ x = \\frac { -b ± \\sqrt{b^2-4ac} } { 2a } $<br>if $ b^2-4ac &lt; 0 $, 无解</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//sph.xyz: center， sph.w: radius</span><br><span class=\"line\">float iSphere(in vec3 ro, in vec3 rd, in vec4 sph)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    vec3 oc = ro - sph.xyz;</span><br><span class=\"line\">    float b = dot( oc, rd ); </span><br><span class=\"line\">    float c = dot(oc,oc) - sph.w*sph.w;</span><br><span class=\"line\">    float h = b*b - c; </span><br><span class=\"line\">    if( h &lt; 0.0 ) return -1.0;</span><br><span class=\"line\">    float t = -b - sqrt(h);</span><br><span class=\"line\">    return t;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"如何检测和平面相交\"><a href=\"#如何检测和平面相交\" class=\"headerlink\" title=\"如何检测和平面相交\"></a>如何检测和平面相交</h5><p>注意这里是指无限大的平面，不是有边界的矩形<br><img src=\"http://www.scratchapixel.com/images/upload/ray-simple-shapes/plane.png?\" alt><br>我们需要的是xz方向的平面，平面上任意一点可以表示为（0，h，0）<br>如果相交，光线和平面的交点$P$到平面上任意一点$P_0$的向量必定和平面法线$n$垂直<br>也就是$PP_0 ·n = 0$<br>=&gt; $ [r_0+t*rd - (0,h,0)] * (0,1,0) = 0 $, 得到 $ t = \\frac{h - r_0.y}{rd.y} $</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">float iPlane(in vec3 ro, in vec3 rd, in float h) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return (h-ro.y)/rd.y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"设置参数搭建场景\"><a href=\"#设置参数搭建场景\" class=\"headerlink\" title=\"设置参数搭建场景\"></a>设置参数搭建场景</h4><p>了解如何检测相交之后，我们就知道了要提供哪些参数<br>$ r_0 $：摄像机的位置，$ rd $：光线方向，$ center $：球心坐标，$ R $：球的半径</p>\n<p>如图所示，$ rd $的集合其实就是这个摄像机视锥，反映了焦距，FOV等<br>而$ r_0 $其实是前后移动摄像机以及视锥，等于摄像机和视锥不动，物体前后移动<br>并不影响透视，镜头拉伸等效果<br><img src=\"/images/Shadertoy_01_02.gif\" alt></p>\n<p>把屏幕坐标转换到[-1,1]，乘以屏幕长宽比确保不会拉伸，这个就是视锥底面的尺寸</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec2 uv = (fragCoord * 2.0 - iResolution.xy ) / iResolution.y</span><br></pre></td></tr></table></figure>\n\n<p>而视锥的长度，即$ rd.z $代表了相机的焦距，会影响到最终画面的透视效果</p>\n<p><img src=\"/images/Shadertoy_01_01.png\" alt=\"rd.z = 2.14的时候\"><br><img src=\"/images/Shadertoy_01_03.png\" alt=\"rd.z = 1.0的时候\"><br>这里的2.14是根据<a href=\"https://www.zhihu.com/question/20086562\" target=\"_blank\" rel=\"noopener\">Jqx1991的回答</a>模拟人眼透视<br>视锥角度为25°, 屏幕高度为1，$ \\frac {1}{tan25°} ≈ 2.14 $<br>调节$ rd.z $可以看到透视慢慢转向广角镜头或者鱼眼镜头的效果<br><img src=\"/images/Shadertoy_01_04.png\" alt></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec3 rd = normalize( vec3(uv, -2.14) )</span><br></pre></td></tr></table></figure>\n\n<p>定义球比较简单，$ xyz $是球心坐标，$ w $是半径</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec4 s1 = vec4(  0.0, 0.0, -5.0, 1.0 )</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"计算最终颜色\"><a href=\"#计算最终颜色\" class=\"headerlink\" title=\"计算最终颜色\"></a>计算最终颜色</h4><p>前面检测相交的函数返回了$ t $<br>因为是从摄像机发出光线射向屏幕，所以交点一定是在摄像机前面，即$ t &gt;0 $<br>光线和三个球体以及平面分别进行相交检测，然后得到最小的$ t $值即最近的交点<br>最开始说过，光线用 $ r_0+t*rd $ 来表示，得到$ t $之后代入，得到交点的坐标信息<br>球体的法线就是从球心到交点向外，平面的法线就是竖直向上<br>然后进行光照计算得到最终结果，这里直接采用了<a href=\"https://www.shadertoy.com/view/MllSRj\" target=\"_blank\" rel=\"noopener\">EKnapik</a>的代码</p>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><p><a href=\"http://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/parametric-and-implicit-surfaces\" target=\"_blank\" rel=\"noopener\">Ray-Tracer</a><br><a href=\"https://www.zhihu.com/question/20086562\" target=\"_blank\" rel=\"noopener\">成像视角</a><br><a href=\"https://www.shadertoy.com/view/MllSRj\" target=\"_blank\" rel=\"noopener\">光照模型</a></p>\n"},{"title":"Shadertoy - 02. Interior Mapping","date":"2019-01-30T06:51:45.000Z","_content":"![](/images/Shadertoy_02_01.png)\n[Shadertoy地址](https://www.shadertoy.com/view/tsX3Dr)\n\n---\n\nInterior Mapping是一种伪造室内场景的实时渲染技术\n不需要建模，在一个平面上就可以渲染出房间的体积感\n\n\n这里是该技术开发者的[博客](http://interiormapping.oogst3d.net/)，里面有paper及demo\n需要了解光线追踪的基础知识，可以看我[上一篇](https://zcx-star.github.io/2019/01/28/Shadertoy-01/)或者[Scratchapixel](http://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes)\n\n实际应用中有两种思路，一种是生成单个房间，然后在房间内划分区域\n另一种是将房间拆分成xyz三个方向的平面，本文实现的是这种\n\n---\n\n#### 实现思路\n1. 设置参数搭建场景\n2. 发射光线，检测是否和物体相交\n3. 计算最终颜色\n\n#### 如何检测相交\n首先只考虑xz方向的平面，平面上任意一点可以表示为（0，h，0）\n如何检测和平面相交在[前一篇](https://zcx-star.github.io/2019/01/28/Shadertoy-01/)里说过了，$ t = \\frac{h - r_0.y}{rd.y} $\n假设两个平面之间间隔为$d$，那么平面的位置$h$可以表示为$n * d$（ $n$为任意整数）\n但是因为平面是无限延伸的，如果直接做检测相交，光线碰到的永远只有最近的两个平面\n![](/images/Shadertoy_02_02.png)\n所以我们需要判断每个像素应该对应的平面坐标$h$，而不是找到最近的相交平面\n\n当摄像机是仰视的时候，我们看到的是高于像素的天花板\n当摄像机是俯视的时候，我们看到的是低于像素的地板\n![](/images/Shadertoy_02_03.png)\n那么我们可以通过判断$rd$的方向来确认是需要向上取整还是向下取整得到$h$\n\n```\nvec2 intersect(in vec3 ro, in vec3 rd, in vec3 Axis, in float d, in float id1, in float id2)\n{\n    float rd_weight = dot( rd, Axis );\n    float ro_weight = dot( ro ,Axis );\n    float pointer = ceil( ro_weight / d );\n    \n    if( rd_weight > 0.0 ) // look up\n    {\n        float h = pointer * d;\n        float t = ( h - ro_weight ) / rd_weight;\n        return vec2( t, id1 );  \n    }\n    else // look down\n    {\n        float h = ( pointer - 1.0 ) * d;\n        float t = ( h - ro_weight ) / rd_weight;\n        return vec2( t, id2 );  \n    }   \n}\n\n```\n\n对三个轴向都完成相交检测后，比较得到最近的$t$，完成相交检测\n\n```\nvec2 nearest(in vec2 c1,in vec2 c2,in vec2 c3)\n{\n    if( c1.x < c2.x )\n    {\n        return c1.x<c3.x? c1:c3;\n    }\n    else\n    {\n        return c2.x<c3.x? c2:c3; \n    }\n}\n```\n\n#### 设置参数搭建场景\n基本跟[上一篇](https://zcx-star.github.io/2019/01/28/Shadertoy-01/)一致，构造正确的摄像机视锥\n\n#### 计算最终颜色\n把坐标位置换算成uv，读取贴图得到最终颜色\n\n#### 参考资料\n[Interior Mapping](http://interiormapping.oogst3d.net/)","source":"_posts/Shadertoy-02.md","raw":"---\ntitle: Shadertoy - 02. Interior Mapping\ndate: 2019-01-30 14:51:45\ntags: Shader\ncategories: Shader\n---\n![](/images/Shadertoy_02_01.png)\n[Shadertoy地址](https://www.shadertoy.com/view/tsX3Dr)\n\n---\n\nInterior Mapping是一种伪造室内场景的实时渲染技术\n不需要建模，在一个平面上就可以渲染出房间的体积感\n\n\n这里是该技术开发者的[博客](http://interiormapping.oogst3d.net/)，里面有paper及demo\n需要了解光线追踪的基础知识，可以看我[上一篇](https://zcx-star.github.io/2019/01/28/Shadertoy-01/)或者[Scratchapixel](http://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes)\n\n实际应用中有两种思路，一种是生成单个房间，然后在房间内划分区域\n另一种是将房间拆分成xyz三个方向的平面，本文实现的是这种\n\n---\n\n#### 实现思路\n1. 设置参数搭建场景\n2. 发射光线，检测是否和物体相交\n3. 计算最终颜色\n\n#### 如何检测相交\n首先只考虑xz方向的平面，平面上任意一点可以表示为（0，h，0）\n如何检测和平面相交在[前一篇](https://zcx-star.github.io/2019/01/28/Shadertoy-01/)里说过了，$ t = \\frac{h - r_0.y}{rd.y} $\n假设两个平面之间间隔为$d$，那么平面的位置$h$可以表示为$n * d$（ $n$为任意整数）\n但是因为平面是无限延伸的，如果直接做检测相交，光线碰到的永远只有最近的两个平面\n![](/images/Shadertoy_02_02.png)\n所以我们需要判断每个像素应该对应的平面坐标$h$，而不是找到最近的相交平面\n\n当摄像机是仰视的时候，我们看到的是高于像素的天花板\n当摄像机是俯视的时候，我们看到的是低于像素的地板\n![](/images/Shadertoy_02_03.png)\n那么我们可以通过判断$rd$的方向来确认是需要向上取整还是向下取整得到$h$\n\n```\nvec2 intersect(in vec3 ro, in vec3 rd, in vec3 Axis, in float d, in float id1, in float id2)\n{\n    float rd_weight = dot( rd, Axis );\n    float ro_weight = dot( ro ,Axis );\n    float pointer = ceil( ro_weight / d );\n    \n    if( rd_weight > 0.0 ) // look up\n    {\n        float h = pointer * d;\n        float t = ( h - ro_weight ) / rd_weight;\n        return vec2( t, id1 );  \n    }\n    else // look down\n    {\n        float h = ( pointer - 1.0 ) * d;\n        float t = ( h - ro_weight ) / rd_weight;\n        return vec2( t, id2 );  \n    }   \n}\n\n```\n\n对三个轴向都完成相交检测后，比较得到最近的$t$，完成相交检测\n\n```\nvec2 nearest(in vec2 c1,in vec2 c2,in vec2 c3)\n{\n    if( c1.x < c2.x )\n    {\n        return c1.x<c3.x? c1:c3;\n    }\n    else\n    {\n        return c2.x<c3.x? c2:c3; \n    }\n}\n```\n\n#### 设置参数搭建场景\n基本跟[上一篇](https://zcx-star.github.io/2019/01/28/Shadertoy-01/)一致，构造正确的摄像机视锥\n\n#### 计算最终颜色\n把坐标位置换算成uv，读取贴图得到最终颜色\n\n#### 参考资料\n[Interior Mapping](http://interiormapping.oogst3d.net/)","slug":"Shadertoy-02","published":1,"updated":"2020-05-13T04:04:41.664Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka4xpxio000h8st14d3t11sh","content":"<p><img src=\"/images/Shadertoy_02_01.png\" alt><br><a href=\"https://www.shadertoy.com/view/tsX3Dr\" target=\"_blank\" rel=\"noopener\">Shadertoy地址</a></p>\n<hr>\n<p>Interior Mapping是一种伪造室内场景的实时渲染技术<br>不需要建模，在一个平面上就可以渲染出房间的体积感</p>\n<p>这里是该技术开发者的<a href=\"http://interiormapping.oogst3d.net/\" target=\"_blank\" rel=\"noopener\">博客</a>，里面有paper及demo<br>需要了解光线追踪的基础知识，可以看我<a href=\"https://zcx-star.github.io/2019/01/28/Shadertoy-01/\" target=\"_blank\" rel=\"noopener\">上一篇</a>或者<a href=\"http://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes\" target=\"_blank\" rel=\"noopener\">Scratchapixel</a></p>\n<p>实际应用中有两种思路，一种是生成单个房间，然后在房间内划分区域<br>另一种是将房间拆分成xyz三个方向的平面，本文实现的是这种</p>\n<hr>\n<h4 id=\"实现思路\"><a href=\"#实现思路\" class=\"headerlink\" title=\"实现思路\"></a>实现思路</h4><ol>\n<li>设置参数搭建场景</li>\n<li>发射光线，检测是否和物体相交</li>\n<li>计算最终颜色</li>\n</ol>\n<h4 id=\"如何检测相交\"><a href=\"#如何检测相交\" class=\"headerlink\" title=\"如何检测相交\"></a>如何检测相交</h4><p>首先只考虑xz方向的平面，平面上任意一点可以表示为（0，h，0）<br>如何检测和平面相交在<a href=\"https://zcx-star.github.io/2019/01/28/Shadertoy-01/\" target=\"_blank\" rel=\"noopener\">前一篇</a>里说过了，$ t = \\frac{h - r_0.y}{rd.y} $<br>假设两个平面之间间隔为$d$，那么平面的位置$h$可以表示为$n * d$（ $n$为任意整数）<br>但是因为平面是无限延伸的，如果直接做检测相交，光线碰到的永远只有最近的两个平面<br><img src=\"/images/Shadertoy_02_02.png\" alt><br>所以我们需要判断每个像素应该对应的平面坐标$h$，而不是找到最近的相交平面</p>\n<p>当摄像机是仰视的时候，我们看到的是高于像素的天花板<br>当摄像机是俯视的时候，我们看到的是低于像素的地板<br><img src=\"/images/Shadertoy_02_03.png\" alt><br>那么我们可以通过判断$rd$的方向来确认是需要向上取整还是向下取整得到$h$</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec2 intersect(in vec3 ro, in vec3 rd, in vec3 Axis, in float d, in float id1, in float id2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    float rd_weight = dot( rd, Axis );</span><br><span class=\"line\">    float ro_weight = dot( ro ,Axis );</span><br><span class=\"line\">    float pointer = ceil( ro_weight / d );</span><br><span class=\"line\">    </span><br><span class=\"line\">    if( rd_weight &gt; 0.0 ) // look up</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        float h = pointer * d;</span><br><span class=\"line\">        float t = ( h - ro_weight ) / rd_weight;</span><br><span class=\"line\">        return vec2( t, id1 );  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else // look down</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        float h = ( pointer - 1.0 ) * d;</span><br><span class=\"line\">        float t = ( h - ro_weight ) / rd_weight;</span><br><span class=\"line\">        return vec2( t, id2 );  </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对三个轴向都完成相交检测后，比较得到最近的$t$，完成相交检测</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec2 nearest(in vec2 c1,in vec2 c2,in vec2 c3)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if( c1.x &lt; c2.x )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return c1.x&lt;c3.x? c1:c3;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return c2.x&lt;c3.x? c2:c3; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"设置参数搭建场景\"><a href=\"#设置参数搭建场景\" class=\"headerlink\" title=\"设置参数搭建场景\"></a>设置参数搭建场景</h4><p>基本跟<a href=\"https://zcx-star.github.io/2019/01/28/Shadertoy-01/\" target=\"_blank\" rel=\"noopener\">上一篇</a>一致，构造正确的摄像机视锥</p>\n<h4 id=\"计算最终颜色\"><a href=\"#计算最终颜色\" class=\"headerlink\" title=\"计算最终颜色\"></a>计算最终颜色</h4><p>把坐标位置换算成uv，读取贴图得到最终颜色</p>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><p><a href=\"http://interiormapping.oogst3d.net/\" target=\"_blank\" rel=\"noopener\">Interior Mapping</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/Shadertoy_02_01.png\" alt><br><a href=\"https://www.shadertoy.com/view/tsX3Dr\" target=\"_blank\" rel=\"noopener\">Shadertoy地址</a></p>\n<hr>\n<p>Interior Mapping是一种伪造室内场景的实时渲染技术<br>不需要建模，在一个平面上就可以渲染出房间的体积感</p>\n<p>这里是该技术开发者的<a href=\"http://interiormapping.oogst3d.net/\" target=\"_blank\" rel=\"noopener\">博客</a>，里面有paper及demo<br>需要了解光线追踪的基础知识，可以看我<a href=\"https://zcx-star.github.io/2019/01/28/Shadertoy-01/\" target=\"_blank\" rel=\"noopener\">上一篇</a>或者<a href=\"http://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes\" target=\"_blank\" rel=\"noopener\">Scratchapixel</a></p>\n<p>实际应用中有两种思路，一种是生成单个房间，然后在房间内划分区域<br>另一种是将房间拆分成xyz三个方向的平面，本文实现的是这种</p>\n<hr>\n<h4 id=\"实现思路\"><a href=\"#实现思路\" class=\"headerlink\" title=\"实现思路\"></a>实现思路</h4><ol>\n<li>设置参数搭建场景</li>\n<li>发射光线，检测是否和物体相交</li>\n<li>计算最终颜色</li>\n</ol>\n<h4 id=\"如何检测相交\"><a href=\"#如何检测相交\" class=\"headerlink\" title=\"如何检测相交\"></a>如何检测相交</h4><p>首先只考虑xz方向的平面，平面上任意一点可以表示为（0，h，0）<br>如何检测和平面相交在<a href=\"https://zcx-star.github.io/2019/01/28/Shadertoy-01/\" target=\"_blank\" rel=\"noopener\">前一篇</a>里说过了，$ t = \\frac{h - r_0.y}{rd.y} $<br>假设两个平面之间间隔为$d$，那么平面的位置$h$可以表示为$n * d$（ $n$为任意整数）<br>但是因为平面是无限延伸的，如果直接做检测相交，光线碰到的永远只有最近的两个平面<br><img src=\"/images/Shadertoy_02_02.png\" alt><br>所以我们需要判断每个像素应该对应的平面坐标$h$，而不是找到最近的相交平面</p>\n<p>当摄像机是仰视的时候，我们看到的是高于像素的天花板<br>当摄像机是俯视的时候，我们看到的是低于像素的地板<br><img src=\"/images/Shadertoy_02_03.png\" alt><br>那么我们可以通过判断$rd$的方向来确认是需要向上取整还是向下取整得到$h$</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec2 intersect(in vec3 ro, in vec3 rd, in vec3 Axis, in float d, in float id1, in float id2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    float rd_weight = dot( rd, Axis );</span><br><span class=\"line\">    float ro_weight = dot( ro ,Axis );</span><br><span class=\"line\">    float pointer = ceil( ro_weight / d );</span><br><span class=\"line\">    </span><br><span class=\"line\">    if( rd_weight &gt; 0.0 ) // look up</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        float h = pointer * d;</span><br><span class=\"line\">        float t = ( h - ro_weight ) / rd_weight;</span><br><span class=\"line\">        return vec2( t, id1 );  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else // look down</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        float h = ( pointer - 1.0 ) * d;</span><br><span class=\"line\">        float t = ( h - ro_weight ) / rd_weight;</span><br><span class=\"line\">        return vec2( t, id2 );  </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对三个轴向都完成相交检测后，比较得到最近的$t$，完成相交检测</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec2 nearest(in vec2 c1,in vec2 c2,in vec2 c3)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if( c1.x &lt; c2.x )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return c1.x&lt;c3.x? c1:c3;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return c2.x&lt;c3.x? c2:c3; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"设置参数搭建场景\"><a href=\"#设置参数搭建场景\" class=\"headerlink\" title=\"设置参数搭建场景\"></a>设置参数搭建场景</h4><p>基本跟<a href=\"https://zcx-star.github.io/2019/01/28/Shadertoy-01/\" target=\"_blank\" rel=\"noopener\">上一篇</a>一致，构造正确的摄像机视锥</p>\n<h4 id=\"计算最终颜色\"><a href=\"#计算最终颜色\" class=\"headerlink\" title=\"计算最终颜色\"></a>计算最终颜色</h4><p>把坐标位置换算成uv，读取贴图得到最终颜色</p>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><p><a href=\"http://interiormapping.oogst3d.net/\" target=\"_blank\" rel=\"noopener\">Interior Mapping</a></p>\n"},{"title":"Shadertoy - 04. Interior Mapping in UE4","date":"2019-10-19T10:29:26.000Z","_content":"\n![](/images/Shadertoy_04_01.png)\nUE4内置的Interiormap节点可以快速实现该效果，这里仅作学习，运行效率并未优化\n左边是普通贴图，各个面可以不一样，右边是一张cuebemap\n![](/images/Shadertoy_04_02.png)\n\n### 1. 普通贴图shader\n![](/images/Shadertoy_04_03.png)\n基本算法照着之前的[Interior mapping](https://zcx-star.github.io/2019/01/30/Shadertoy-02/)\n注意，如果照之前的做法，将UV映射到[-1,1]，最少显示2x2的房间，中间的面无法消除\n所以这里将UV保持在[0,1]区间，不做映射\nFOV改成0.001，因为视锥角度为90度，$ \\frac {1}{tan90°} $ 无限趋近0，所以设置为尽量小的0.001 \n![](/images/Shadertoy_04_04.png)\n---\n\n![](/images/Shadertoy_04_05.png)\n\n```\n// Intersect 照搬之前的算法\nfloat rd_weight = dot( rd, Axis );\nfloat ro_weight = dot( ro ,Axis );\nfloat pointer = ceil( ro_weight / d );\n\nif( rd_weight > 0.0 ) // look up\n{\n    float h1 = pointer * d;\n    float t1 = ( h1 - ro_weight ) / rd_weight;\n    return float2( t1, id1 );  \n}\nelse // look down\n{\n    float h2 = ( pointer - 1.0 ) * d;\n    float t2 = ( h2 - ro_weight ) / rd_weight;\n    return float2( t2, id2 );  \n}  \n```\n\n```\n// Nearest 照搬之前的算法\nif( c1.x < c2.x )\n{\n    return c1.x<c3.x? c1:c3;\n}\nelse\n{\n    return c2.x<c3.x? c2:c3; \n} \n```\n\n```\n//render 照搬之前的算法\nfloat t = tID.x;\nfloat id = tID.y;   \n\nfloat3 pos = ro + t*rd;\npos = pos / size;\n\nif (id>0.9 && id<1.1) //top\n{\n    return float3( frac(pos.xz), 1.0 );       \n}  \nelse if (id>1.9 && id<2.1) //bottom\n{\n    return float3( frac(float2(pos.x,-pos.z)), 2.0 );\n}\nelse if (id>2.9 && id<3.1) //right\n{\n    return float3( frac(float2(-pos.z,-pos.y)), 3.0 );\n}\nelse if (id>3.9 && id<4.1) //left\n{\n    return float3( frac(float2(pos.z,-pos.y)), 4.0 );\n}\nelse if (id>4.9 && id<5.1)  //front\n{\n    return float3( frac(float2(pos.x,-pos.y)), 5.0 );\n}\nelse if (id>5.9 && id<6.1)  //back\n{\n    return float3( frac(pos.xy), 6.0 );\n} \nelse\n{\n    return float3( frac(float2(pos.x,-pos.z)), 7.0 );\n}  \n```\n![](/images/Shadertoy_04_06.png)\n\n### 2. Cubemap shader\n\n![](/images/Shadertoy_04_07.png)\n前面到Nearest都是一样的，cubemap用position信息作为UV\n```\nfloat t = tID.x;\nfloat id = tID.y;   \n\nfloat3 pos = ro + t*rd;\npos = pos / size;\n\nreturn pos;\n```\n因为开头UV是在[0,1]，原点没有移到中心，所以-0.5映射到[-0.5,0.5]，即原点在中心\n然后根据官方Interiormap节点的效果做了坐标轴转换\n![](/images/Shadertoy_04_08.png)\n同时，为了模拟深度不同的房间，把size.z改成了0.2，可以看到房间进深变浅了\n![](/images/Shadertoy_04_09.png)\n","source":"_posts/Shadertoy-04.md","raw":"---\ntitle: Shadertoy - 04. Interior Mapping in UE4\ndate: 2019-10-19 18:29:26\ntags: Shader\ncategories: Shader\n---\n\n![](/images/Shadertoy_04_01.png)\nUE4内置的Interiormap节点可以快速实现该效果，这里仅作学习，运行效率并未优化\n左边是普通贴图，各个面可以不一样，右边是一张cuebemap\n![](/images/Shadertoy_04_02.png)\n\n### 1. 普通贴图shader\n![](/images/Shadertoy_04_03.png)\n基本算法照着之前的[Interior mapping](https://zcx-star.github.io/2019/01/30/Shadertoy-02/)\n注意，如果照之前的做法，将UV映射到[-1,1]，最少显示2x2的房间，中间的面无法消除\n所以这里将UV保持在[0,1]区间，不做映射\nFOV改成0.001，因为视锥角度为90度，$ \\frac {1}{tan90°} $ 无限趋近0，所以设置为尽量小的0.001 \n![](/images/Shadertoy_04_04.png)\n---\n\n![](/images/Shadertoy_04_05.png)\n\n```\n// Intersect 照搬之前的算法\nfloat rd_weight = dot( rd, Axis );\nfloat ro_weight = dot( ro ,Axis );\nfloat pointer = ceil( ro_weight / d );\n\nif( rd_weight > 0.0 ) // look up\n{\n    float h1 = pointer * d;\n    float t1 = ( h1 - ro_weight ) / rd_weight;\n    return float2( t1, id1 );  \n}\nelse // look down\n{\n    float h2 = ( pointer - 1.0 ) * d;\n    float t2 = ( h2 - ro_weight ) / rd_weight;\n    return float2( t2, id2 );  \n}  \n```\n\n```\n// Nearest 照搬之前的算法\nif( c1.x < c2.x )\n{\n    return c1.x<c3.x? c1:c3;\n}\nelse\n{\n    return c2.x<c3.x? c2:c3; \n} \n```\n\n```\n//render 照搬之前的算法\nfloat t = tID.x;\nfloat id = tID.y;   \n\nfloat3 pos = ro + t*rd;\npos = pos / size;\n\nif (id>0.9 && id<1.1) //top\n{\n    return float3( frac(pos.xz), 1.0 );       \n}  \nelse if (id>1.9 && id<2.1) //bottom\n{\n    return float3( frac(float2(pos.x,-pos.z)), 2.0 );\n}\nelse if (id>2.9 && id<3.1) //right\n{\n    return float3( frac(float2(-pos.z,-pos.y)), 3.0 );\n}\nelse if (id>3.9 && id<4.1) //left\n{\n    return float3( frac(float2(pos.z,-pos.y)), 4.0 );\n}\nelse if (id>4.9 && id<5.1)  //front\n{\n    return float3( frac(float2(pos.x,-pos.y)), 5.0 );\n}\nelse if (id>5.9 && id<6.1)  //back\n{\n    return float3( frac(pos.xy), 6.0 );\n} \nelse\n{\n    return float3( frac(float2(pos.x,-pos.z)), 7.0 );\n}  \n```\n![](/images/Shadertoy_04_06.png)\n\n### 2. Cubemap shader\n\n![](/images/Shadertoy_04_07.png)\n前面到Nearest都是一样的，cubemap用position信息作为UV\n```\nfloat t = tID.x;\nfloat id = tID.y;   \n\nfloat3 pos = ro + t*rd;\npos = pos / size;\n\nreturn pos;\n```\n因为开头UV是在[0,1]，原点没有移到中心，所以-0.5映射到[-0.5,0.5]，即原点在中心\n然后根据官方Interiormap节点的效果做了坐标轴转换\n![](/images/Shadertoy_04_08.png)\n同时，为了模拟深度不同的房间，把size.z改成了0.2，可以看到房间进深变浅了\n![](/images/Shadertoy_04_09.png)\n","slug":"Shadertoy-04","published":1,"updated":"2020-05-13T04:04:41.665Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka4xpxis000i8st11aiiedkm","content":"<p><img src=\"/images/Shadertoy_04_01.png\" alt><br>UE4内置的Interiormap节点可以快速实现该效果，这里仅作学习，运行效率并未优化<br>左边是普通贴图，各个面可以不一样，右边是一张cuebemap<br><img src=\"/images/Shadertoy_04_02.png\" alt></p>\n<h3 id=\"1-普通贴图shader\"><a href=\"#1-普通贴图shader\" class=\"headerlink\" title=\"1. 普通贴图shader\"></a>1. 普通贴图shader</h3><p><img src=\"/images/Shadertoy_04_03.png\" alt><br>基本算法照着之前的<a href=\"https://zcx-star.github.io/2019/01/30/Shadertoy-02/\" target=\"_blank\" rel=\"noopener\">Interior mapping</a><br>注意，如果照之前的做法，将UV映射到[-1,1]，最少显示2x2的房间，中间的面无法消除<br>所以这里将UV保持在[0,1]区间，不做映射<br>FOV改成0.001，因为视锥角度为90度，$ \\frac {1}{tan90°} $ 无限趋近0，所以设置为尽量小的0.001 </p>\n<h2 id><a href=\"#\" class=\"headerlink\" title></a><img src=\"/images/Shadertoy_04_04.png\" alt></h2><p><img src=\"/images/Shadertoy_04_05.png\" alt></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Intersect 照搬之前的算法</span><br><span class=\"line\">float rd_weight = dot( rd, Axis );</span><br><span class=\"line\">float ro_weight = dot( ro ,Axis );</span><br><span class=\"line\">float pointer = ceil( ro_weight / d );</span><br><span class=\"line\"></span><br><span class=\"line\">if( rd_weight &gt; 0.0 ) // look up</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    float h1 = pointer * d;</span><br><span class=\"line\">    float t1 = ( h1 - ro_weight ) / rd_weight;</span><br><span class=\"line\">    return float2( t1, id1 );  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">else // look down</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    float h2 = ( pointer - 1.0 ) * d;</span><br><span class=\"line\">    float t2 = ( h2 - ro_weight ) / rd_weight;</span><br><span class=\"line\">    return float2( t2, id2 );  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Nearest 照搬之前的算法</span><br><span class=\"line\">if( c1.x &lt; c2.x )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return c1.x&lt;c3.x? c1:c3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">else</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return c2.x&lt;c3.x? c2:c3; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//render 照搬之前的算法</span><br><span class=\"line\">float t = tID.x;</span><br><span class=\"line\">float id = tID.y;   </span><br><span class=\"line\"></span><br><span class=\"line\">float3 pos = ro + t*rd;</span><br><span class=\"line\">pos = pos / size;</span><br><span class=\"line\"></span><br><span class=\"line\">if (id&gt;0.9 &amp;&amp; id&lt;1.1) //top</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return float3( frac(pos.xz), 1.0 );       </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">else if (id&gt;1.9 &amp;&amp; id&lt;2.1) //bottom</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return float3( frac(float2(pos.x,-pos.z)), 2.0 );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">else if (id&gt;2.9 &amp;&amp; id&lt;3.1) //right</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return float3( frac(float2(-pos.z,-pos.y)), 3.0 );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">else if (id&gt;3.9 &amp;&amp; id&lt;4.1) //left</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return float3( frac(float2(pos.z,-pos.y)), 4.0 );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">else if (id&gt;4.9 &amp;&amp; id&lt;5.1)  //front</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return float3( frac(float2(pos.x,-pos.y)), 5.0 );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">else if (id&gt;5.9 &amp;&amp; id&lt;6.1)  //back</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return float3( frac(pos.xy), 6.0 );</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">else</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return float3( frac(float2(pos.x,-pos.z)), 7.0 );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/Shadertoy_04_06.png\" alt></p>\n<h3 id=\"2-Cubemap-shader\"><a href=\"#2-Cubemap-shader\" class=\"headerlink\" title=\"2. Cubemap shader\"></a>2. Cubemap shader</h3><p><img src=\"/images/Shadertoy_04_07.png\" alt><br>前面到Nearest都是一样的，cubemap用position信息作为UV</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">float t = tID.x;</span><br><span class=\"line\">float id = tID.y;   </span><br><span class=\"line\"></span><br><span class=\"line\">float3 pos = ro + t*rd;</span><br><span class=\"line\">pos = pos / size;</span><br><span class=\"line\"></span><br><span class=\"line\">return pos;</span><br></pre></td></tr></table></figure>\n\n<p>因为开头UV是在[0,1]，原点没有移到中心，所以-0.5映射到[-0.5,0.5]，即原点在中心<br>然后根据官方Interiormap节点的效果做了坐标轴转换<br><img src=\"/images/Shadertoy_04_08.png\" alt><br>同时，为了模拟深度不同的房间，把size.z改成了0.2，可以看到房间进深变浅了<br><img src=\"/images/Shadertoy_04_09.png\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/Shadertoy_04_01.png\" alt><br>UE4内置的Interiormap节点可以快速实现该效果，这里仅作学习，运行效率并未优化<br>左边是普通贴图，各个面可以不一样，右边是一张cuebemap<br><img src=\"/images/Shadertoy_04_02.png\" alt></p>\n<h3 id=\"1-普通贴图shader\"><a href=\"#1-普通贴图shader\" class=\"headerlink\" title=\"1. 普通贴图shader\"></a>1. 普通贴图shader</h3><p><img src=\"/images/Shadertoy_04_03.png\" alt><br>基本算法照着之前的<a href=\"https://zcx-star.github.io/2019/01/30/Shadertoy-02/\" target=\"_blank\" rel=\"noopener\">Interior mapping</a><br>注意，如果照之前的做法，将UV映射到[-1,1]，最少显示2x2的房间，中间的面无法消除<br>所以这里将UV保持在[0,1]区间，不做映射<br>FOV改成0.001，因为视锥角度为90度，$ \\frac {1}{tan90°} $ 无限趋近0，所以设置为尽量小的0.001 </p>\n<h2 id><a href=\"#\" class=\"headerlink\" title></a><img src=\"/images/Shadertoy_04_04.png\" alt></h2><p><img src=\"/images/Shadertoy_04_05.png\" alt></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Intersect 照搬之前的算法</span><br><span class=\"line\">float rd_weight = dot( rd, Axis );</span><br><span class=\"line\">float ro_weight = dot( ro ,Axis );</span><br><span class=\"line\">float pointer = ceil( ro_weight / d );</span><br><span class=\"line\"></span><br><span class=\"line\">if( rd_weight &gt; 0.0 ) // look up</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    float h1 = pointer * d;</span><br><span class=\"line\">    float t1 = ( h1 - ro_weight ) / rd_weight;</span><br><span class=\"line\">    return float2( t1, id1 );  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">else // look down</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    float h2 = ( pointer - 1.0 ) * d;</span><br><span class=\"line\">    float t2 = ( h2 - ro_weight ) / rd_weight;</span><br><span class=\"line\">    return float2( t2, id2 );  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Nearest 照搬之前的算法</span><br><span class=\"line\">if( c1.x &lt; c2.x )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return c1.x&lt;c3.x? c1:c3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">else</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return c2.x&lt;c3.x? c2:c3; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//render 照搬之前的算法</span><br><span class=\"line\">float t = tID.x;</span><br><span class=\"line\">float id = tID.y;   </span><br><span class=\"line\"></span><br><span class=\"line\">float3 pos = ro + t*rd;</span><br><span class=\"line\">pos = pos / size;</span><br><span class=\"line\"></span><br><span class=\"line\">if (id&gt;0.9 &amp;&amp; id&lt;1.1) //top</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return float3( frac(pos.xz), 1.0 );       </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">else if (id&gt;1.9 &amp;&amp; id&lt;2.1) //bottom</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return float3( frac(float2(pos.x,-pos.z)), 2.0 );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">else if (id&gt;2.9 &amp;&amp; id&lt;3.1) //right</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return float3( frac(float2(-pos.z,-pos.y)), 3.0 );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">else if (id&gt;3.9 &amp;&amp; id&lt;4.1) //left</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return float3( frac(float2(pos.z,-pos.y)), 4.0 );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">else if (id&gt;4.9 &amp;&amp; id&lt;5.1)  //front</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return float3( frac(float2(pos.x,-pos.y)), 5.0 );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">else if (id&gt;5.9 &amp;&amp; id&lt;6.1)  //back</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return float3( frac(pos.xy), 6.0 );</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">else</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return float3( frac(float2(pos.x,-pos.z)), 7.0 );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/Shadertoy_04_06.png\" alt></p>\n<h3 id=\"2-Cubemap-shader\"><a href=\"#2-Cubemap-shader\" class=\"headerlink\" title=\"2. Cubemap shader\"></a>2. Cubemap shader</h3><p><img src=\"/images/Shadertoy_04_07.png\" alt><br>前面到Nearest都是一样的，cubemap用position信息作为UV</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">float t = tID.x;</span><br><span class=\"line\">float id = tID.y;   </span><br><span class=\"line\"></span><br><span class=\"line\">float3 pos = ro + t*rd;</span><br><span class=\"line\">pos = pos / size;</span><br><span class=\"line\"></span><br><span class=\"line\">return pos;</span><br></pre></td></tr></table></figure>\n\n<p>因为开头UV是在[0,1]，原点没有移到中心，所以-0.5映射到[-0.5,0.5]，即原点在中心<br>然后根据官方Interiormap节点的效果做了坐标轴转换<br><img src=\"/images/Shadertoy_04_08.png\" alt><br>同时，为了模拟深度不同的房间，把size.z改成了0.2，可以看到房间进深变浅了<br><img src=\"/images/Shadertoy_04_09.png\" alt></p>\n"},{"title":"Shadertoy - 03. Cubemap","date":"2019-04-19T07:11:46.000Z","_content":"```\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord * 2.0 - iResolution.xy )/iResolution.y;\n    \n    vec3 cameraPos = vec3(0.0, 0.0, 0.0);\n    vec3 targetPos = vec3(cos(iTime), 0.0, sin(iTime));\n\n    // camera space    \n    vec3 yAxis = vec3(0.0, 1.0, 0.0);    \n    vec3 zAxis = normalize(targetPos - cameraPos);\n    vec3 xAxis = normalize(cross(zAxis, yAxis));\n    \n    float fov = 90.0;    \n    float a = radians(fov/2.0);\n\n    // ==============================    \n\n    // 1. cube\n    vec3 pos = normalize(uv.x * xAxis + uv.y * yAxis + 1.0/tan(a) * zAxis); \n    \n    // 2. sphere     \n    /*float z = sqrt(1.0 - uv.x*uv.x - uv.y*uv.y);\n    vec3 pos = normalize(uv.x * xAxis + uv.y * yAxis + z * zAxis); */\n\n    // ==============================\n    \n    fragColor = vec4(texture(iChannel0, pos).xyz, 1.0);\n}\n```\n![](/images/Shadertoy_03_01.png)\n### 1. cube\n世界坐标为（ uv, 1.0/tan(a) ），camera space坐标系为（xAxis, yAxis, zAxis ）\n坐标系转换world->camera: \nvec3 pos = normalize(uv.x \\* xAxis + uv.y \\* yAxis + 1.0/tan(a) \\* zAxis); \n\n### 2. sphere\nsphere半径为1，求出z，得到世界坐标，转换到camera space","source":"_posts/Shadertoy-03.md","raw":"---\ntitle: Shadertoy - 03. Cubemap\ndate: 2019-04-19 15:11:46\ntags: Shader\ncategories: Shader\n---\n```\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord * 2.0 - iResolution.xy )/iResolution.y;\n    \n    vec3 cameraPos = vec3(0.0, 0.0, 0.0);\n    vec3 targetPos = vec3(cos(iTime), 0.0, sin(iTime));\n\n    // camera space    \n    vec3 yAxis = vec3(0.0, 1.0, 0.0);    \n    vec3 zAxis = normalize(targetPos - cameraPos);\n    vec3 xAxis = normalize(cross(zAxis, yAxis));\n    \n    float fov = 90.0;    \n    float a = radians(fov/2.0);\n\n    // ==============================    \n\n    // 1. cube\n    vec3 pos = normalize(uv.x * xAxis + uv.y * yAxis + 1.0/tan(a) * zAxis); \n    \n    // 2. sphere     \n    /*float z = sqrt(1.0 - uv.x*uv.x - uv.y*uv.y);\n    vec3 pos = normalize(uv.x * xAxis + uv.y * yAxis + z * zAxis); */\n\n    // ==============================\n    \n    fragColor = vec4(texture(iChannel0, pos).xyz, 1.0);\n}\n```\n![](/images/Shadertoy_03_01.png)\n### 1. cube\n世界坐标为（ uv, 1.0/tan(a) ），camera space坐标系为（xAxis, yAxis, zAxis ）\n坐标系转换world->camera: \nvec3 pos = normalize(uv.x \\* xAxis + uv.y \\* yAxis + 1.0/tan(a) \\* zAxis); \n\n### 2. sphere\nsphere半径为1，求出z，得到世界坐标，转换到camera space","slug":"Shadertoy-03","published":1,"updated":"2020-05-13T04:04:41.665Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka4xpxiw000m8st1e3l3y124","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void mainImage( out vec4 fragColor, in vec2 fragCoord )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    vec2 uv = ( fragCoord * 2.0 - iResolution.xy )/iResolution.y;</span><br><span class=\"line\">    </span><br><span class=\"line\">    vec3 cameraPos = vec3(0.0, 0.0, 0.0);</span><br><span class=\"line\">    vec3 targetPos = vec3(cos(iTime), 0.0, sin(iTime));</span><br><span class=\"line\"></span><br><span class=\"line\">    // camera space    </span><br><span class=\"line\">    vec3 yAxis = vec3(0.0, 1.0, 0.0);    </span><br><span class=\"line\">    vec3 zAxis = normalize(targetPos - cameraPos);</span><br><span class=\"line\">    vec3 xAxis = normalize(cross(zAxis, yAxis));</span><br><span class=\"line\">    </span><br><span class=\"line\">    float fov = 90.0;    </span><br><span class=\"line\">    float a = radians(fov/2.0);</span><br><span class=\"line\"></span><br><span class=\"line\">    // ==============================    </span><br><span class=\"line\"></span><br><span class=\"line\">    // 1. cube</span><br><span class=\"line\">    vec3 pos = normalize(uv.x * xAxis + uv.y * yAxis + 1.0/tan(a) * zAxis); </span><br><span class=\"line\">    </span><br><span class=\"line\">    // 2. sphere     </span><br><span class=\"line\">    /*float z = sqrt(1.0 - uv.x*uv.x - uv.y*uv.y);</span><br><span class=\"line\">    vec3 pos = normalize(uv.x * xAxis + uv.y * yAxis + z * zAxis); */</span><br><span class=\"line\"></span><br><span class=\"line\">    // ==============================</span><br><span class=\"line\">    </span><br><span class=\"line\">    fragColor = vec4(texture(iChannel0, pos).xyz, 1.0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/Shadertoy_03_01.png\" alt></p>\n<h3 id=\"1-cube\"><a href=\"#1-cube\" class=\"headerlink\" title=\"1. cube\"></a>1. cube</h3><p>世界坐标为（ uv, 1.0/tan(a) ），camera space坐标系为（xAxis, yAxis, zAxis ）<br>坐标系转换world-&gt;camera:<br>vec3 pos = normalize(uv.x * xAxis + uv.y * yAxis + 1.0/tan(a) * zAxis); </p>\n<h3 id=\"2-sphere\"><a href=\"#2-sphere\" class=\"headerlink\" title=\"2. sphere\"></a>2. sphere</h3><p>sphere半径为1，求出z，得到世界坐标，转换到camera space</p>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void mainImage( out vec4 fragColor, in vec2 fragCoord )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    vec2 uv = ( fragCoord * 2.0 - iResolution.xy )/iResolution.y;</span><br><span class=\"line\">    </span><br><span class=\"line\">    vec3 cameraPos = vec3(0.0, 0.0, 0.0);</span><br><span class=\"line\">    vec3 targetPos = vec3(cos(iTime), 0.0, sin(iTime));</span><br><span class=\"line\"></span><br><span class=\"line\">    // camera space    </span><br><span class=\"line\">    vec3 yAxis = vec3(0.0, 1.0, 0.0);    </span><br><span class=\"line\">    vec3 zAxis = normalize(targetPos - cameraPos);</span><br><span class=\"line\">    vec3 xAxis = normalize(cross(zAxis, yAxis));</span><br><span class=\"line\">    </span><br><span class=\"line\">    float fov = 90.0;    </span><br><span class=\"line\">    float a = radians(fov/2.0);</span><br><span class=\"line\"></span><br><span class=\"line\">    // ==============================    </span><br><span class=\"line\"></span><br><span class=\"line\">    // 1. cube</span><br><span class=\"line\">    vec3 pos = normalize(uv.x * xAxis + uv.y * yAxis + 1.0/tan(a) * zAxis); </span><br><span class=\"line\">    </span><br><span class=\"line\">    // 2. sphere     </span><br><span class=\"line\">    /*float z = sqrt(1.0 - uv.x*uv.x - uv.y*uv.y);</span><br><span class=\"line\">    vec3 pos = normalize(uv.x * xAxis + uv.y * yAxis + z * zAxis); */</span><br><span class=\"line\"></span><br><span class=\"line\">    // ==============================</span><br><span class=\"line\">    </span><br><span class=\"line\">    fragColor = vec4(texture(iChannel0, pos).xyz, 1.0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/Shadertoy_03_01.png\" alt></p>\n<h3 id=\"1-cube\"><a href=\"#1-cube\" class=\"headerlink\" title=\"1. cube\"></a>1. cube</h3><p>世界坐标为（ uv, 1.0/tan(a) ），camera space坐标系为（xAxis, yAxis, zAxis ）<br>坐标系转换world-&gt;camera:<br>vec3 pos = normalize(uv.x * xAxis + uv.y * yAxis + 1.0/tan(a) * zAxis); </p>\n<h3 id=\"2-sphere\"><a href=\"#2-sphere\" class=\"headerlink\" title=\"2. sphere\"></a>2. sphere</h3><p>sphere半径为1，求出z，得到世界坐标，转换到camera space</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cka4xpxhx00008st1tss2b1v4","category_id":"cka4xpxi800038st1pt8p4p87","_id":"cka4xpxin000e8st1jcn4oyo3"},{"post_id":"cka4xpxi500028st1bjzi9f0f","category_id":"cka4xpxi800038st1pt8p4p87","_id":"cka4xpxit000j8st15ut9mkua"},{"post_id":"cka4xpxia00058st144z64i43","category_id":"cka4xpxin000d8st1rtinm0w5","_id":"cka4xpxiy000p8st18p7tkybw"},{"post_id":"cka4xpxid00068st1dtxiwwyi","category_id":"cka4xpxin000d8st1rtinm0w5","_id":"cka4xpxj0000t8st18kjshhf2"},{"post_id":"cka4xpxij000b8st10b4whpmj","category_id":"cka4xpxin000d8st1rtinm0w5","_id":"cka4xpxj0000w8st1i2khxosa"},{"post_id":"cka4xpxil000c8st1h1vvs6o2","category_id":"cka4xpxiz000s8st1ghndkebh","_id":"cka4xpxj300118st15p1jckwk"},{"post_id":"cka4xpxio000h8st14d3t11sh","category_id":"cka4xpxiz000s8st1ghndkebh","_id":"cka4xpxj500158st1hv1esvba"},{"post_id":"cka4xpxis000i8st11aiiedkm","category_id":"cka4xpxiz000s8st1ghndkebh","_id":"cka4xpxj600188st1qra9bw8z"},{"post_id":"cka4xpxiw000m8st1e3l3y124","category_id":"cka4xpxiz000s8st1ghndkebh","_id":"cka4xpxj7001a8st1vymc90ef"}],"PostTag":[{"post_id":"cka4xpxhx00008st1tss2b1v4","tag_id":"cka4xpxia00048st11xvpd8dt","_id":"cka4xpxij000a8st1d9vczkb4"},{"post_id":"cka4xpxi500028st1bjzi9f0f","tag_id":"cka4xpxia00048st11xvpd8dt","_id":"cka4xpxio000g8st1ogk9dcxt"},{"post_id":"cka4xpxia00058st144z64i43","tag_id":"cka4xpxin000f8st1ysh75a40","_id":"cka4xpxix000n8st11v0e7lbl"},{"post_id":"cka4xpxid00068st1dtxiwwyi","tag_id":"cka4xpxin000f8st1ysh75a40","_id":"cka4xpxiz000r8st1ti95hmnh"},{"post_id":"cka4xpxij000b8st10b4whpmj","tag_id":"cka4xpxin000f8st1ysh75a40","_id":"cka4xpxj0000v8st1bif29249"},{"post_id":"cka4xpxil000c8st1h1vvs6o2","tag_id":"cka4xpxj0000u8st1fqvd3402","_id":"cka4xpxj2000z8st1w6qu91nf"},{"post_id":"cka4xpxio000h8st14d3t11sh","tag_id":"cka4xpxj0000u8st1fqvd3402","_id":"cka4xpxj400138st1amkkxx38"},{"post_id":"cka4xpxis000i8st11aiiedkm","tag_id":"cka4xpxj0000u8st1fqvd3402","_id":"cka4xpxj600178st1rcspqrxg"},{"post_id":"cka4xpxiw000m8st1e3l3y124","tag_id":"cka4xpxj0000u8st1fqvd3402","_id":"cka4xpxj600198st12ue4dy8e"}],"Tag":[{"name":"Directx11","_id":"cka4xpxia00048st11xvpd8dt"},{"name":"Real Time Rendering","_id":"cka4xpxin000f8st1ysh75a40"},{"name":"Shader","_id":"cka4xpxj0000u8st1fqvd3402"}]}}